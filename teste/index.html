<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>Avatar por pose</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 25% 25%, #ffffff 0, #f6f8fc 45%, #e6ecfb 100%);
      color: #1f2a44;
    }

    h1 {
      font-size: 1.6rem;
      margin: 0;
    }

    #info {
      font-size: 0.95rem;
      opacity: 0.75;
    }

    main {
      width: min(560px, 92vw);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #stage {
      width: 100%;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 16px;
      box-shadow: 0 12px 32px rgba(30, 70, 140, 0.12);
      padding: clamp(12px, 3vw, 28px);
    }

    #stage svg {
      width: 100%;
      height: auto;
      display: block;
    }

    #debugControls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      justify-content: center;
      background: rgba(74, 139, 255, 0.08);
      border-radius: 999px;
      padding: 0.6rem 1rem;
      border: 1px solid rgba(74, 139, 255, 0.18);
    }

    #debugControls span {
      font-weight: 600;
      font-size: 0.9rem;
      letter-spacing: 0.01em;
    }

    .debug-toggle {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      font-weight: 600;
      color: #1f2a44;
      background: rgba(74, 139, 255, 0.18);
      cursor: pointer;
      transition: background 120ms ease, color 120ms ease, box-shadow 120ms ease;
      box-shadow: inset 0 0 0 1px rgba(74, 139, 255, 0.1);
    }

    .debug-toggle:hover {
      background: rgba(74, 139, 255, 0.28);
    }

    .debug-toggle.inactive {
      background: rgba(125, 139, 166, 0.14);
      color: rgba(31, 42, 68, 0.6);
      box-shadow: inset 0 0 0 1px rgba(125, 139, 166, 0.18);
    }

    .joint {
      transform-box: fill-box;
      transform-origin: center;
      transition: transform 60ms linear;
    }

    #L_upper,
    #L_lower,
    #R_upper,
    #R_lower {
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.15));
    }

    #error {
      position: fixed;
      bottom: 1.2rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(220, 53, 69, 0.92);
      color: #fff;
      padding: 0.8rem 1.2rem;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
      display: none;
      max-width: min(480px, 90vw);
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Avatar 2D animado por <code>.pose</code></h1>
  <div id="info">Animando a partir de <code>pose_frames.json</code></div>
  <main>
    <div id="stage" aria-live="polite"></div>
  </main>
  <section id="debugControls" aria-label="Alternar linhas de debug">
    <span>Linhas de debug:</span>
    <button type="button" class="debug-toggle" data-toggle-target="leftArm" aria-pressed="true">Braço esquerdo</button>
    <button type="button" class="debug-toggle" data-toggle-target="rightArm" aria-pressed="true">Braço direito</button>
    <button type="button" class="debug-toggle" data-toggle-target="body" aria-pressed="true">Corpo</button>
    <button type="button" class="debug-toggle" data-toggle-target="face" aria-pressed="true">Rosto</button>
  </section>
  <div id="error" role="alert"></div>
  <script>
    const stage = document.getElementById('stage');
    const errorBox = document.getElementById('error');
    const NS = 'http://www.w3.org/2000/svg';

    const showError = (msg) => {
      errorBox.textContent = msg;
      errorBox.style.display = 'block';
    };

    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    const angle = (a, b) => Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI;

    const PUPPET_LEFT_SH = { x: 605.7, y: 294.3 };
    const PUPPET_RIGHT_SH = { x: 392.8, y: 294.3 };
    const PUPPET_LEFT_EL = { x: 710.1, y: 294.0 };
    const PUPPET_LEFT_WR = { x: 873.5, y: 300.3 };
    const PUPPET_SHOULDER_SPAN = PUPPET_LEFT_SH.x - PUPPET_RIGHT_SH.x;
    const PUPPET_SHOULDERS_MID = {
      x: (PUPPET_LEFT_SH.x + PUPPET_RIGHT_SH.x) / 2,
      y: PUPPET_LEFT_SH.y
    };
    const PUPPET_UPPER_ARM_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_EL);
    const PUPPET_LOWER_ARM_LEN = dist(PUPPET_LEFT_EL, PUPPET_LEFT_WR);

    const DEBUG_ARM = new URLSearchParams(window.location.search).get('debugArm') !== '0';
    const smooth = {};
    const debugToggles = {
      leftArm: true,
      rightArm: true,
      body: true,
      face: true
    };

    const EMA = (prev, cur, a = 0.35) => {
      if (!prev) return cur;
      return {
        x: prev.x + a * (cur.x - prev.x),
        y: prev.y + a * (cur.y - prev.y)
      };
    };

    const mid = (a, b) => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 });

    function safeKP(kp, name) {
      const prev = smooth[name] ?? null;
      const raw = kp?.[name] ?? null;
      let next = null;
      if (raw && prev) next = EMA(prev, raw);
      else next = raw || prev || null;
      smooth[name] = next;
      return next;
    }

    function rigFromPose(kp) {
      const LSh = safeKP(kp, 'leftShoulder');
      const RSh = safeKP(kp, 'rightShoulder');
      const LH = safeKP(kp, 'leftHip');
      const RH = safeKP(kp, 'rightHip');
      if (!LSh || !RSh || !LH || !RH) return null;
      const poseSpan = dist(LSh, RSh);
      if (!poseSpan) return null;
      return {
        scale: PUPPET_SHOULDER_SPAN / poseSpan,
        origin: mid(LSh, RSh),
        offset: PUPPET_SHOULDERS_MID
      };
    }

    const toRig = (p, rig) => ({
      x: rig.offset.x + (p.x - rig.origin.x) * rig.scale,
      y: rig.offset.y + (p.y - rig.origin.y) * rig.scale
    });

    function placeLine(line, start, end) {
      if (!line || !start || !end) return;
      line.setAttribute('x1', start.x);
      line.setAttribute('y1', start.y);
      line.setAttribute('x2', end.x);
      line.setAttribute('y2', end.y);
    }

    function placePolyline(polyline, points) {
      if (!polyline || !Array.isArray(points) || !points.length) return;
      const serialized = points.map((pt) => `${pt.x},${pt.y}`).join(' ');
      polyline.setAttribute('points', serialized);
    }

    function placeRigLine(line, from, to, rig) {
      if (!line || !from || !to || !rig) return;
      const A = toRig(from, rig);
      const B = toRig(to, rig);
      placeLine(line, A, B);
    }

    function clampAngle(prev, next) {
      if (prev == null || Number.isNaN(prev)) return next;
      let candidate = next;
      let delta = candidate - prev;
      while (delta > 180) {
        candidate -= 360;
        delta = candidate - prev;
      }
      while (delta < -180) {
        candidate += 360;
        delta = candidate - prev;
      }
      return candidate;
    }

    function isDebugActive() {
      return DEBUG_ARM || !puppetArmReady;
    }

    function updateVisibility() {
      const showDebug = isDebugActive();
      const showLeft = showDebug && debugToggles.leftArm;
      const showRight = showDebug && debugToggles.rightArm;
      const showBody = showDebug && debugToggles.body;
      const showFace = showDebug && debugToggles.face;

      if (armPath) armPath.style.display = showLeft ? 'block' : 'none';

      const toggle = (elements, show) => {
        for (const el of elements) {
          if (!el) continue;
          el.style.display = show ? 'block' : 'none';
        }
      };

      toggle([segments.left.upper, segments.left.lower], showLeft);
      toggle([segments.right.upper, segments.right.lower], showRight);
      toggle([
        segments.body.top,
        segments.body.bottom,
        segments.body.left,
        segments.body.right,
        segments.body.center
      ], showBody);

      toggle(segments.face.map((guide) => guide.polyline), showFace);

      if (puppetOverlay.upper) {
        puppetOverlay.upper.style.display = puppetArmReady ? 'none' : 'block';
      }
      if (puppetOverlay.lower) {
        puppetOverlay.lower.style.display = puppetArmReady ? 'none' : 'block';
      }
      if (upperArmEl) upperArmEl.style.display = showDebug ? 'none' : '';
      if (lowerArmEl) lowerArmEl.style.display = showDebug ? 'none' : '';
    }

    let frames = [];
    let frameIndex = 0;
    let svgEl = null;
    const segments = {
      left: { upper: null, lower: null },
      right: { upper: null, lower: null },
      body: { top: null, bottom: null, left: null, right: null, center: null },
      face: []
    };
    let armPath = null;
    let running = false;
    let upperArmEl = null;
    let lowerArmEl = null;
    let puppetArmReady = false;
    let puppetWarningShown = false;
    let lastArmRig = null;
    const lastArmAngles = { upper: null, lower: null };
    const puppetOverlay = { upper: null, lower: null };

    function seg(id, stroke = '#4a8bff', width = 10) {
      const line = document.createElementNS(NS, 'line');
      line.id = id;
      line.setAttribute('stroke', stroke);
      line.setAttribute('stroke-width', width);
      line.setAttribute('stroke-linecap', 'round');
      line.classList.add('joint');
      svgEl.appendChild(line);
      return line;
    }

    function faceGuide(id, stroke = '#4a8bff', width = 6) {
      const poly = document.createElementNS(NS, 'polyline');
      poly.id = id;
      poly.setAttribute('fill', 'none');
      poly.setAttribute('stroke', stroke);
      poly.setAttribute('stroke-width', width);
      poly.setAttribute('stroke-linecap', 'round');
      poly.setAttribute('stroke-linejoin', 'round');
      poly.classList.add('joint');
      svgEl.appendChild(poly);
      return poly;
    }

    function readPoint(id) {
      if (!svgEl) return null;
      const el = svgEl.getElementById(id);
      if (!el) return null;
      const cx = el.getAttribute('cx') ?? el.getAttribute('x') ?? el.getAttribute('x1');
      const cy = el.getAttribute('cy') ?? el.getAttribute('y') ?? el.getAttribute('y1');
      if (cx == null || cy == null) return null;
      const x = parseFloat(cx);
      const y = parseFloat(cy);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x, y };
    }

    function setPolylinePoints(polyline, pointIds) {
      if (!polyline || !Array.isArray(pointIds)) return null;
      const pts = [];
      for (const id of pointIds) {
        const pt = readPoint(id);
        if (!pt) return null;
        pts.push(pt);
      }
      placePolyline(polyline, pts);
      return pts;
    }

    function rotatePuppetSegment(el, origin, target, key) {
      if (!el || !origin || !target) return;
      const ang = clampAngle(lastArmAngles[key], angle(origin, target));
      lastArmAngles[key] = ang;
      el.style.transformOrigin = `${origin.x}px ${origin.y}px`;
      el.style.transform = `rotate(${ang}deg)`;
    }

    function placeOverlaySegment(line, from, to) {
      if (!line || !from || !to) return;
      line.setAttribute('x1', from.x);
      line.setAttribute('y1', from.y);
      line.setAttribute('x2', to.x);
      line.setAttribute('y2', to.y);
    }

    function alignArmToPuppet(rawArm) {
      if (!rawArm) return null;
      const { A, B, C } = rawArm;
      if (!A || !B || !C) return null;
      const upperDx = B.x - A.x;
      const upperDy = B.y - A.y;
      const upperLen = Math.hypot(upperDx, upperDy);
      if (upperLen < 1e-3) return null;
      const upperUnitX = upperDx / upperLen;
      const upperUnitY = upperDy / upperLen;
      const alignedB = {
        x: A.x + upperUnitX * PUPPET_UPPER_ARM_LEN,
        y: A.y + upperUnitY * PUPPET_UPPER_ARM_LEN
      };

      const lowerDx = C.x - B.x;
      const lowerDy = C.y - B.y;
      const lowerLen = Math.hypot(lowerDx, lowerDy);
      if (lowerLen < 1e-3) {
        return { A, B: alignedB, C: alignedB };
      }
      const lowerUnitX = lowerDx / lowerLen;
      const lowerUnitY = lowerDy / lowerLen;
      const alignedC = {
        x: alignedB.x + lowerUnitX * PUPPET_LOWER_ARM_LEN,
        y: alignedB.y + lowerUnitY * PUPPET_LOWER_ARM_LEN
      };

      return { A, B: alignedB, C: alignedC };
    }

    function updateFaceGuides(kp, rig) {
      if (!rig || !segments.face.length) return;
      for (const guide of segments.face) {
        const { polyline, ids, fallback } = guide;
        const points = [];
        for (let i = 0; i < ids.length; i += 1) {
          const id = ids[i];
          const raw = safeKP(kp, id);
          if (raw) {
            points.push(toRig(raw, rig));
          } else if (fallback && fallback[i]) {
            points.push(fallback[i]);
          } else {
            points.length = 0;
            break;
          }
        }

        if (points.length === ids.length) {
          placePolyline(polyline, points);
        } else if (fallback && fallback.length) {
          placePolyline(polyline, fallback);
        }
      }
    }

    function tick() {
      if (!frames.length) return;
      const frame = frames[frameIndex];
      const kp = frame?.keypoints;
      if (!kp) {
        frameIndex = (frameIndex + 1) % frames.length;
        requestAnimationFrame(tick);
        return;
      }

      const rig = rigFromPose(kp);
      if (!rig) {
        frameIndex = (frameIndex + 1) % frames.length;
        requestAnimationFrame(tick);
        return;
      }

      const LSh = safeKP(kp, 'leftShoulder');
      const LE = safeKP(kp, 'leftElbow');
      const LW = safeKP(kp, 'leftWrist');
      const RSh = safeKP(kp, 'rightShoulder');
      const RE = safeKP(kp, 'rightElbow');
      const RW = safeKP(kp, 'rightWrist');
      const LH = safeKP(kp, 'leftHip');
      const RH = safeKP(kp, 'rightHip');

      let currentArmRig = null;
      if (LSh && LE && LW) {
        const rawRig = {
          A: toRig(LSh, rig),
          B: toRig(LE, rig),
          C: toRig(LW, rig)
        };
        currentArmRig = alignArmToPuppet(rawRig) || rawRig;
        lastArmRig = currentArmRig;
      } else if (lastArmRig) {
        currentArmRig = lastArmRig;
      }

      if (currentArmRig && armPath) {
        const { A, B, C } = currentArmRig;
        armPath.setAttribute('d', `M ${A.x} ${A.y} L ${B.x} ${B.y} L ${C.x} ${C.y}`);
      }

      const showDebug = isDebugActive();

      if (currentArmRig) {
        const { A, B, C } = currentArmRig;
        placeOverlaySegment(puppetOverlay.upper, A, B);
        placeOverlaySegment(puppetOverlay.lower, B, C);
      }

      if (currentArmRig && showDebug) {
        const { A, B, C } = currentArmRig;
        placeLine(segments.left.upper, A, B);
        placeLine(segments.left.lower, B, C);
      }

      if (currentArmRig && !showDebug && puppetArmReady) {
        const { A, B, C } = currentArmRig;
        rotatePuppetSegment(upperArmEl, A, B, 'upper');
        rotatePuppetSegment(lowerArmEl, B, C, 'lower');
      }

      if (showDebug) {
        if (RSh && RE) placeRigLine(segments.right.upper, RSh, RE, rig);
        if (RE && RW) placeRigLine(segments.right.lower, RE, RW, rig);
        if (LSh && RSh) placeRigLine(segments.body.top, LSh, RSh, rig);
        if (LH && RH) placeRigLine(segments.body.bottom, LH, RH, rig);
        if (LSh && LH) placeRigLine(segments.body.left, LSh, LH, rig);
        if (RSh && RH) placeRigLine(segments.body.right, RSh, RH, rig);
        if (LSh && RSh && LH && RH) {
          placeRigLine(segments.body.center, mid(LSh, RSh), mid(LH, RH), rig);
        }
      }

      updateFaceGuides(kp, rig);

      frameIndex = (frameIndex + 1) % frames.length;
      requestAnimationFrame(tick);
    }

    function tryStart() {
      if (!running && svgEl && frames.length) {
        running = true;
        requestAnimationFrame(tick);
      }
    }

    fetch('../boy.svg')
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status} ao carregar boy.svg`);
        return res.text();
      })
      .then((svgMarkup) => {
        stage.innerHTML = svgMarkup;
        svgEl = stage.querySelector('svg');
        if (!svgEl) throw new Error('boy.svg não possui elemento <svg>');
        svgEl.removeAttribute('width');
        svgEl.removeAttribute('height');
        svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svgEl.style.width = '100%';
        svgEl.style.height = 'auto';
        const skel = svgEl.getElementById('skeleton_1_');
        if (skel) skel.style.display = 'none';
        armPath = document.createElementNS(NS, 'path');
        armPath.id = 'L_arm_path';
        armPath.setAttribute('fill', 'none');
        armPath.setAttribute('stroke', '#4a8bff');
        armPath.setAttribute('stroke-width', '18');
        armPath.setAttribute('stroke-linecap', 'round');
        armPath.setAttribute('stroke-linejoin', 'round');
        svgEl.appendChild(armPath);
        segments.left.upper = seg('L_upper');
        segments.left.lower = seg('L_lower');
        segments.right.upper = seg('R_upper');
        segments.right.lower = seg('R_lower');
        segments.body.top = seg('body_top', '#4a8bff', 12);
        segments.body.bottom = seg('body_bottom', '#4a8bff', 12);
        segments.body.left = seg('body_left', '#4a8bff', 12);
        segments.body.right = seg('body_right', '#4a8bff', 12);
        segments.body.center = seg('body_center', '#4a8bff', 10);

        const faceGuides = [
          { id: 'face_contour', ids: [
            'topMid', 'rightTop0', 'rightTop1', 'rightJaw0', 'rightJaw1', 'rightJaw2',
            'rightJaw3', 'rightJaw4', 'rightJaw5', 'rightJaw6', 'rightJaw7', 'jawMid',
            'leftJaw7', 'leftJaw6', 'leftJaw5', 'leftJaw4', 'leftJaw3', 'leftJaw2',
            'leftJaw1', 'leftJaw0', 'leftTop1', 'leftTop0', 'topMid'
          ], width: 8 },
          { id: 'face_brow_right', ids: ['rightBrow0', 'rightBrow1', 'rightBrow2', 'rightBrow3', 'rightBrow4'] },
          { id: 'face_brow_left', ids: ['leftBrow0', 'leftBrow1', 'leftBrow2', 'leftBrow3', 'leftBrow4'] },
          { id: 'face_eye_right', ids: ['rightEye0', 'rightEye1', 'rightEye2', 'rightEye3', 'rightEye4', 'rightEye5', 'rightEye0'], width: 5 },
          { id: 'face_eye_left', ids: ['leftEye0', 'leftEye1', 'leftEye2', 'leftEye3', 'leftEye4', 'leftEye5', 'leftEye0'], width: 5 },
          { id: 'face_nose_bridge', ids: ['nose0', 'nose1', 'nose2', 'nose3', 'nose4'] },
          { id: 'face_nose_base', ids: ['rightNose0', 'rightNose1', 'nose4', 'leftNose1', 'leftNose0'], width: 5 },
          { id: 'face_mouth_outer', ids: [
            'rightMouthCorner', 'rightUpperLipTop0', 'rightUpperLipTop1', 'upperLipTopMid',
            'leftUpperLipTop1', 'leftUpperLipTop0', 'leftMouthCorner', 'leftLowerLipBottom0',
            'leftLowerLipBottom1', 'lowerLipBottomMid', 'rightLowerLipBottom1', 'rightLowerLipBottom0',
            'rightMouthCorner'
          ], width: 7 },
          { id: 'face_mouth_inner', ids: [
            'rightMouthCorner', 'rightUpperLipBottom1', 'upperLipBottomMid', 'leftUpperLipBottom1',
            'leftMouthCorner', 'leftLowerLipTop0', 'lowerLipTopMid', 'rightLowerLipTop0', 'rightMouthCorner'
          ], width: 4 }
        ];

        for (const guide of faceGuides) {
          const poly = faceGuide(guide.id, '#4a8bff', guide.width ?? 6);
          const fallback = setPolylinePoints(poly, guide.ids);
          if (!fallback) {
            console.warn(`Não foi possível construir a linha de rosto ${guide.id}`);
            poly.remove();
            continue;
          }
          segments.face.push({ polyline: poly, ids: guide.ids, fallback });
        }

        puppetOverlay.upper = document.createElementNS(NS, 'line');
        puppetOverlay.upper.id = 'leftArmUpperOverlay';
        puppetOverlay.upper.setAttribute('stroke', '#99AFB1');
        puppetOverlay.upper.setAttribute('stroke-linecap', 'round');
        puppetOverlay.upper.setAttribute('stroke-width', '46');
        puppetOverlay.upper.setAttribute('opacity', '0.92');
        puppetOverlay.upper.style.pointerEvents = 'none';
        svgEl.appendChild(puppetOverlay.upper);

        puppetOverlay.lower = document.createElementNS(NS, 'line');
        puppetOverlay.lower.id = 'leftArmLowerOverlay';
        puppetOverlay.lower.setAttribute('stroke', '#F3AF9D');
        puppetOverlay.lower.setAttribute('stroke-linecap', 'round');
        puppetOverlay.lower.setAttribute('stroke-width', '40');
        puppetOverlay.lower.setAttribute('opacity', '0.96');
        puppetOverlay.lower.style.pointerEvents = 'none';
        svgEl.appendChild(puppetOverlay.lower);

        const upperCandidates = [
          'leftUpperArm',
          'LeftUpperArm',
          'left_upper_arm',
          'Left_arm_upper',
          'leftArmUpper',
          'leftupperarm',
          'leftArm_Upper'
        ];
        const lowerCandidates = [
          'leftLowerArm',
          'LeftLowerArm',
          'left_lower_arm',
          'Left_arm_lower',
          'leftArmLower',
          'leftlowerarm',
          'leftArm_Lower'
        ];

        const findArmPart = (candidates) => {
          for (const id of candidates) {
            const el = svgEl.getElementById(id);
            if (el) return el;
          }
          return null;
        };

        upperArmEl = findArmPart(upperCandidates);
        lowerArmEl = findArmPart(lowerCandidates);
        puppetArmReady = Boolean(upperArmEl && lowerArmEl);

        if (!puppetArmReady && !puppetWarningShown) {
          console.warn('Braço esquerdo do puppet não encontrado em boy.svg; mantendo modo debug.');
          puppetWarningShown = true;
        }

        if (upperArmEl) {
          upperArmEl.style.transformBox = 'fill-box';
          upperArmEl.classList.add('joint');
        }
        if (lowerArmEl) {
          lowerArmEl.style.transformBox = 'fill-box';
          lowerArmEl.classList.add('joint');
        }

        if (upperArmEl && upperArmEl.parentNode) {
          upperArmEl.parentNode.appendChild(upperArmEl);
        }
        if (lowerArmEl && lowerArmEl.parentNode) {
          lowerArmEl.parentNode.appendChild(lowerArmEl);
        }

        updateVisibility();
        tryStart();
      })
      .catch((err) => {
        console.error(err);
        showError('Erro ao carregar boy.svg: ' + err.message);
      });

    fetch('pose_frames.json')
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status} ao carregar pose_frames.json`);
        return res.json();
      })
      .then((data) => {
        if (!Array.isArray(data) || !data.length) {
          throw new Error('Arquivo pose_frames.json vazio ou inválido.');
        }
        frames = data;
        tryStart();
      })
      .catch((err) => {
        console.error(err);
        showError('Erro ao carregar pose_frames.json: ' + err.message);
      });

    const toggleButtons = Array.from(document.querySelectorAll('[data-toggle-target]'));
    toggleButtons.forEach((button) => {
      const target = button.dataset.toggleTarget;
      if (!target || !(target in debugToggles)) return;
      button.addEventListener('click', () => {
        debugToggles[target] = !debugToggles[target];
        button.classList.toggle('inactive', !debugToggles[target]);
        button.setAttribute('aria-pressed', String(debugToggles[target]));
        updateVisibility();
      });
    });
  </script>
</body>
</html>
