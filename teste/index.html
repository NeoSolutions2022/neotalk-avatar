<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>Avatar por pose</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 25% 25%, #ffffff 0, #f6f8fc 45%, #e6ecfb 100%);
      color: #1f2a44;
    }

    h1 {
      font-size: 1.6rem;
      margin: 0;
    }

    #info {
      font-size: 0.95rem;
      opacity: 0.75;
    }

    main {
      width: min(560px, 92vw);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #stage {
      width: 100%;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 16px;
      box-shadow: 0 12px 32px rgba(30, 70, 140, 0.12);
      padding: clamp(12px, 3vw, 28px);
    }

    #stage svg {
      width: 100%;
      height: auto;
      display: block;
    }

    #debugControls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      justify-content: center;
      background: rgba(74, 139, 255, 0.08);
      border-radius: 999px;
      padding: 0.6rem 1rem;
      border: 1px solid rgba(74, 139, 255, 0.18);
    }

    #debugControls span {
      font-weight: 600;
      font-size: 0.9rem;
      letter-spacing: 0.01em;
    }

    .debug-toggle {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      font-weight: 600;
      color: #1f2a44;
      background: rgba(74, 139, 255, 0.18);
      cursor: pointer;
      transition: background 120ms ease, color 120ms ease, box-shadow 120ms ease;
      box-shadow: inset 0 0 0 1px rgba(74, 139, 255, 0.1);
    }

    .debug-toggle:hover {
      background: rgba(74, 139, 255, 0.28);
    }

    .debug-toggle.inactive {
      background: rgba(125, 139, 166, 0.14);
      color: rgba(31, 42, 68, 0.6);
      box-shadow: inset 0 0 0 1px rgba(125, 139, 166, 0.18);
    }

    .joint {
      transform-box: fill-box;
      transform-origin: center;
      transition: transform 60ms linear;
    }

    #L_upper,
    #L_lower,
    #R_upper,
    #R_lower {
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.15));
    }

    #error {
      position: fixed;
      bottom: 1.2rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(220, 53, 69, 0.92);
      color: #fff;
      padding: 0.8rem 1.2rem;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
      display: none;
      max-width: min(480px, 90vw);
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Avatar 2D animado por <code>.pose</code></h1>
  <div id="info">Animando a partir de <code>pose_frames.json</code></div>
  <main>
    <div id="stage" aria-live="polite"></div>
  </main>
  <section id="debugControls" aria-label="Alternar linhas de debug">
    <span>Linhas de debug:</span>
    <button type="button" class="debug-toggle" data-toggle-target="leftArm" aria-pressed="true">Braço esquerdo</button>
    <button type="button" class="debug-toggle" data-toggle-target="rightArm" aria-pressed="true">Braço direito</button>
    <button type="button" class="debug-toggle" data-toggle-target="body" aria-pressed="true">Corpo</button>
    <button type="button" class="debug-toggle" data-toggle-target="face" aria-pressed="true">Rosto</button>
  </section>
  <div id="error" role="alert"></div>
  <script>
    const stage = document.getElementById('stage');
    const errorBox = document.getElementById('error');
    const NS = 'http://www.w3.org/2000/svg';

    const showError = (msg) => {
      errorBox.textContent = msg;
      errorBox.style.display = 'block';
    };

    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    const mid = (a, b) => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 });
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const formatFloat = (value) => {
      if (!Number.isFinite(value)) return '0';
      const fixed = Number(value).toFixed(2);
      const trimmed = fixed.replace(/\.0+$/, '').replace(/(\.\d+?)0+$/, '$1');
      return trimmed === '-0' ? '0' : trimmed;
    };

    function normalizeLoopPoints(points) {
      if (!Array.isArray(points) || points.length < 2) return points || [];
      const first = points[0];
      const last = points[points.length - 1];
      if (!first || !last) return points;
      if (Math.hypot(first.x - last.x, first.y - last.y) < 1e-3) {
        return points.slice(0, -1);
      }
      return points;
    }

    function centroid(points) {
      if (!Array.isArray(points) || !points.length) return { x: 0, y: 0 };
      let sumX = 0;
      let sumY = 0;
      for (const pt of points) {
        sumX += pt.x;
        sumY += pt.y;
      }
      const count = points.length;
      return { x: sumX / count, y: sumY / count };
    }

    function polygonArea(points) {
      if (!Array.isArray(points) || points.length < 3) return 0;
      let area = 0;
      const len = points.length;
      for (let i = 0; i < len; i += 1) {
        const p0 = points[i];
        const p1 = points[(i + 1) % len];
        area += p0.x * p1.y - p1.x * p0.y;
      }
      return Math.abs(area / 2);
    }

    function buildSmoothPath(points, { closed = false, tension = 0.5 } = {}) {
      if (!Array.isArray(points) || points.length < 2) return '';
      const pts = points.slice();
      if (pts.length === 2) {
        const [start, end] = pts;
        return `M ${formatFloat(start.x)} ${formatFloat(start.y)} L ${formatFloat(end.x)} ${formatFloat(end.y)}`;
      }

      const len = pts.length;
      const safeTension = clamp(tension, 0, 1);
      const getPoint = (idx) => {
        if (closed) {
          const wrapped = (idx % len + len) % len;
          return pts[wrapped];
        }
        if (idx < 0) return pts[0];
        if (idx >= len) return pts[len - 1];
        return pts[idx];
      };

      let path = `M ${formatFloat(pts[0].x)} ${formatFloat(pts[0].y)}`;
      const segments = closed ? len : len - 1;
      for (let i = 0; i < segments; i += 1) {
        const p0 = getPoint(i - 1);
        const p1 = getPoint(i);
        const p2 = getPoint(i + 1);
        const p3 = getPoint(i + 2);
        if (!p1 || !p2 || !p0 || !p3) continue;
        const c1x = p1.x + (p2.x - p0.x) * (safeTension / 6);
        const c1y = p1.y + (p2.y - p0.y) * (safeTension / 6);
        const c2x = p2.x - (p3.x - p1.x) * (safeTension / 6);
        const c2y = p2.y - (p3.y - p1.y) * (safeTension / 6);
        path += ` C ${formatFloat(c1x)} ${formatFloat(c1y)} ${formatFloat(c2x)} ${formatFloat(c2y)} ${formatFloat(p2.x)} ${formatFloat(p2.y)}`;
      }
      if (closed) path += ' Z';
      return path;
    }

    const PUPPET_LEFT_SH = { x: 605.7, y: 294.3 };
    const PUPPET_RIGHT_SH = { x: 392.8, y: 294.3 };
    const PUPPET_LEFT_EL = { x: 710.1, y: 294.0 };
    const PUPPET_LEFT_WR = { x: 873.5, y: 300.3 };
    const PUPPET_RIGHT_EL = { x: 289.3, y: 294.4 };
    const PUPPET_RIGHT_WR = { x: 125.9, y: 300.8 };
    const PUPPET_SHOULDERS_MID = {
      x: (PUPPET_LEFT_SH.x + PUPPET_RIGHT_SH.x) / 2,
      y: PUPPET_LEFT_SH.y
    };
    let PUPPET_UPPER_ARM_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_EL);
    let PUPPET_LOWER_ARM_LEN = dist(PUPPET_LEFT_EL, PUPPET_LEFT_WR);
    let PUPPET_RIGHT_UPPER_ARM_LEN = dist(PUPPET_RIGHT_SH, PUPPET_RIGHT_EL);
    let PUPPET_RIGHT_LOWER_ARM_LEN = dist(PUPPET_RIGHT_EL, PUPPET_RIGHT_WR);
    const PUPPET_LEFT_HIP = { x: 559.5, y: 509.3 };
    const PUPPET_RIGHT_HIP = { x: 443.1, y: 510.1 };
    let PUPPET_HIP_SPAN = dist(PUPPET_LEFT_HIP, PUPPET_RIGHT_HIP);
    let PUPPET_TORSO_CENTER_LEN = dist(
      PUPPET_SHOULDERS_MID,
      mid(PUPPET_LEFT_HIP, PUPPET_RIGHT_HIP)
    );
    let PUPPET_LEFT_TORSO_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_HIP);
    let PUPPET_RIGHT_TORSO_LEN = dist(PUPPET_RIGHT_SH, PUPPET_RIGHT_HIP);
    const PUPPET_BODY_BASE = [
      { ...PUPPET_RIGHT_SH },
      { ...PUPPET_LEFT_SH },
      { ...PUPPET_RIGHT_HIP },
      { ...PUPPET_LEFT_HIP }
    ];
    const PUPPET_ARM_BASES = {
      left: {
        upper: [{ ...PUPPET_LEFT_SH }, { ...PUPPET_LEFT_EL }],
        lower: [{ ...PUPPET_LEFT_EL }, { ...PUPPET_LEFT_WR }]
      },
      right: {
        upper: [{ ...PUPPET_RIGHT_SH }, { ...PUPPET_RIGHT_EL }],
        lower: [{ ...PUPPET_RIGHT_EL }, { ...PUPPET_RIGHT_WR }]
      }
    };

    const DEBUG_ARM = new URLSearchParams(window.location.search).get('debugArm') !== '0';
    const smooth = {};
    const debugToggles = {
      leftArm: DEBUG_ARM,
      rightArm: DEBUG_ARM,
      body: true,
      face: true
    };
    let faceTemplatesRoot = null;
    let faceOverlayLayer = null;
    let headTargets = [];
    let bodyTargets = [];
    let lastHeadMatrix = null;
    let lastBodyMatrix = null;
    let lastRigMatrix = null;
    const HEAD_ANCHOR_ID = 'jawMid';
    const FACE_ANCHOR_ADJUST = { x: 0, y: 6 };
    const FACE_TEMPLATE_POINT_PAIRS = [
      { skeleton: 'upperLipBottomMid', template: 'upperLipBottomMid_1_' },
      { skeleton: 'lowerLipTopMid', template: 'lowerLipTopMid_2_' },
      { skeleton: 'rightEye0', template: 'rightEye0_1_' },
      { skeleton: 'leftEye0', template: 'leftEye0_1_' },
      { skeleton: 'nose4', template: 'nose4_1_' },
      { skeleton: 'rightBrow2', template: 'rightBrow2_1_' },
      { skeleton: 'leftBrow2', template: 'leftBrow2_1_' }
    ];
    let headAnchorBase = null;
    let headAnchorOffset = null;
    const VALIDATION_TOLERANCE = 12;
    const validationNotified = new Set();

    const EMA = (prev, cur, a = 0.35) => {
      if (!prev) return cur;
      return {
        x: prev.x + a * (cur.x - prev.x),
        y: prev.y + a * (cur.y - prev.y)
      };
    };

    function safeKP(kp, name) {
      const prev = smooth[name] ?? null;
      const raw = kp?.[name] ?? null;
      let next = null;
      if (raw && prev) next = EMA(prev, raw);
      else next = raw || prev || null;
      smooth[name] = next;
      return next;
    }

    function rigFromPose(kp) {
      const LSh = safeKP(kp, 'leftShoulder');
      const RSh = safeKP(kp, 'rightShoulder');
      if (!LSh || !RSh) return lastRigMatrix;
      const matrix = computeSimilarityTransform(
        [RSh, LSh],
        [PUPPET_RIGHT_SH, PUPPET_LEFT_SH]
      );
      if (!matrix) return lastRigMatrix;
      lastRigMatrix = matrix;
      return matrix;
    }

    const toRig = (p, rig) => {
      if (!rig || !p) return null;
      const { a, b, c, d, e, f } = rig;
      return {
        x: a * p.x + c * p.y + e,
        y: b * p.x + d * p.y + f
      };
    };

    const transformPoint = (matrix, point) => {
      if (!matrix || !point) return null;
      const { a, b, c, d, e, f } = matrix;
      return {
        x: a * point.x + c * point.y + e,
        y: b * point.x + d * point.y + f
      };
    };

    function placeLine(line, start, end) {
      if (!line || !start || !end) return;
      line.setAttribute('x1', start.x);
      line.setAttribute('y1', start.y);
      line.setAttribute('x2', end.x);
      line.setAttribute('y2', end.y);
    }

    function placePolyline(polyline, points) {
      if (!polyline || !Array.isArray(points) || !points.length) return;
      const serialized = points.map((pt) => `${pt.x},${pt.y}`).join(' ');
      polyline.setAttribute('points', serialized);
    }

    function computeSimilarityTransform(fromPoints, toPoints) {
      if (!Array.isArray(fromPoints) || !Array.isArray(toPoints)) return null;
      const count = Math.min(fromPoints.length, toPoints.length);
      if (!count) return null;
      if (count === 1) {
        const from = fromPoints[0];
        const to = toPoints[0];
        if (!from || !to) return null;
        return {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: to.x - from.x,
          f: to.y - from.y
        };
      }

      let sumFx = 0;
      let sumFy = 0;
      let sumTx = 0;
      let sumTy = 0;
      for (let i = 0; i < count; i += 1) {
        const from = fromPoints[i];
        const to = toPoints[i];
        if (!from || !to) return null;
        sumFx += from.x;
        sumFy += from.y;
        sumTx += to.x;
        sumTy += to.y;
      }

      const meanFrom = { x: sumFx / count, y: sumFy / count };
      const meanTo = { x: sumTx / count, y: sumTy / count };

      let denom = 0;
      let dot = 0;
      let cross = 0;
      for (let i = 0; i < count; i += 1) {
        const from = fromPoints[i];
        const to = toPoints[i];
        const fx = from.x - meanFrom.x;
        const fy = from.y - meanFrom.y;
        const tx = to.x - meanTo.x;
        const ty = to.y - meanTo.y;
        denom += fx * fx + fy * fy;
        dot += fx * tx + fy * ty;
        cross += fx * ty - fy * tx;
      }

      if (denom < 1e-6) {
        return {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: meanTo.x - meanFrom.x,
          f: meanTo.y - meanFrom.y
        };
      }

      const norm = Math.hypot(dot, cross);
      if (norm < 1e-6) {
        return {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: meanTo.x - meanFrom.x,
          f: meanTo.y - meanFrom.y
        };
      }

      const scale = norm / denom;
      const cos = dot / norm;
      const sin = cross / norm;
      const a = scale * cos;
      const b = scale * sin;
      const c = -scale * sin;
      const d = scale * cos;
      const e = meanTo.x - (a * meanFrom.x + c * meanFrom.y);
      const f = meanTo.y - (b * meanFrom.x + d * meanFrom.y);

      return { a, b, c, d, e, f };
    }

    function adjustMatrixTranslation(matrix, pairs) {
      if (!matrix || !Array.isArray(pairs) || !pairs.length) return matrix;
      let offsetX = 0;
      let offsetY = 0;
      let count = 0;
      for (const pair of pairs) {
        if (!pair || !pair.base || !pair.target) continue;
        const current = transformPoint(matrix, pair.base);
        if (!current) continue;
        offsetX += pair.target.x - current.x;
        offsetY += pair.target.y - current.y;
        count += 1;
      }
      if (!count) return matrix;
      return {
        ...matrix,
        e: matrix.e + offsetX / count,
        f: matrix.f + offsetY / count
      };
    }

    function validateSegment(label, basePoints, targetPoints, matrix) {
      if (!matrix || !Array.isArray(basePoints) || !Array.isArray(targetPoints)) return;
      const count = Math.min(basePoints.length, targetPoints.length);
      if (!count) return;
      let maxError = 0;
      for (let i = 0; i < count; i += 1) {
        const source = basePoints[i];
        const target = targetPoints[i];
        if (!source || !target) continue;
        const transformed = transformPoint(matrix, source);
        if (!transformed) continue;
        const error = dist(transformed, target);
        if (error > maxError) {
          maxError = error;
        }
      }
      if (maxError > VALIDATION_TOLERANCE && !validationNotified.has(label)) {
        console.warn(`Alinhamento do segmento ${label} excedeu a tolerância (${formatFloat(maxError)}px).`);
        validationNotified.add(label);
      }
    }

    function applyHeadTransform(matrix) {
      if (!headTargets.length) return;
      if (matrix) {
        const { a, b, c, d, e, f } = matrix;
        for (const target of headTargets) {
          if (target) target.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
        }
        lastHeadMatrix = { a, b, c, d, e, f };
        return;
      }
      if (lastHeadMatrix) {
        const { a, b, c, d, e, f } = lastHeadMatrix;
        for (const target of headTargets) {
          if (target) target.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
        }
        return;
      }
      for (const target of headTargets) {
        if (target) target.removeAttribute('transform');
      }
    }

    function applyBodyTransform(matrix) {
      if (!bodyTargets.length) return;
      if (matrix) {
        const { a, b, c, d, e, f } = matrix;
        for (const target of bodyTargets) {
          if (target) target.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
        }
        lastBodyMatrix = { a, b, c, d, e, f };
        return;
      }
      if (lastBodyMatrix) {
        const { a, b, c, d, e, f } = lastBodyMatrix;
        for (const target of bodyTargets) {
          if (target) target.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
        }
        return;
      }
      for (const target of bodyTargets) {
        if (target) target.removeAttribute('transform');
      }
    }

    function updateVisibility() {
      const showLeft = debugToggles.leftArm;
      const showRight = debugToggles.rightArm;
      const showBody = debugToggles.body;
      const showFace = debugToggles.face;

      if (armPaths.left) armPaths.left.style.display = showLeft ? 'block' : 'none';
      if (armPaths.right) armPaths.right.style.display = showRight ? 'block' : 'none';

      const toggle = (elements, show) => {
        for (const el of elements) {
          if (!el) continue;
          el.style.display = show ? 'block' : 'none';
        }
      };

      toggle([segments.left.upper, segments.left.lower], showLeft);
      toggle([segments.right.upper, segments.right.lower], showRight);
      toggle([
        segments.body.top,
        segments.body.bottom,
        segments.body.left,
        segments.body.right,
        segments.body.center
      ], showBody);

      toggle(segments.face.map((guide) => guide.debug), showFace);

      const updateArmElements = (side) => {
        const arm = puppetArms[side];
        if (!arm) return;
        const visible = arm.ready;
        if (arm.upper) arm.upper.style.display = visible ? '' : 'none';
        if (arm.lower) arm.lower.style.display = visible ? '' : 'none';
      };

      updateArmElements('left');
      updateArmElements('right');
    }

    let frames = [];
    let frameIndex = 0;
    let svgEl = null;
    const segments = {
      left: { upper: null, lower: null },
      right: { upper: null, lower: null },
      body: { top: null, bottom: null, left: null, right: null, center: null },
      face: []
    };
    const armPaths = { left: null, right: null };
    let running = false;
    const puppetArms = {
      left: { upper: null, lower: null, ready: false, warningShown: false, base: { upper: null, lower: null } },
      right: { upper: null, lower: null, ready: false, warningShown: false, base: { upper: null, lower: null } }
    };
    const lastArmRigs = { left: null, right: null };
    const lastArmMatrices = {
      left: { upper: null, lower: null },
      right: { upper: null, lower: null }
    };

    function configureArmElement(el) {
      if (!el) return;
      el.style.transformBox = 'fill-box';
      el.style.transformOrigin = '50% 50%';
      el.removeAttribute('transform');
      el.style.transform = '';
    }

    function ensurePuppetArm(side) {
      const arm = puppetArms[side];
      const bases = PUPPET_ARM_BASES?.[side];
      if (!arm || !bases) {
        if (arm) arm.ready = false;
        return false;
      }
      const { upper, lower } = arm;
      if (!upper || !lower) {
        arm.ready = false;
        return false;
      }
      configureArmElement(upper);
      configureArmElement(lower);
      arm.base.upper = bases.upper ? bases.upper.map((pt) => ({ x: pt.x, y: pt.y })) : null;
      arm.base.lower = bases.lower ? bases.lower.map((pt) => ({ x: pt.x, y: pt.y })) : null;
      arm.ready = Boolean(arm.base.upper && arm.base.lower);
      if (!arm.ready) {
        return false;
      }
      lastArmMatrices[side].upper = null;
      lastArmMatrices[side].lower = null;
      return true;
    }

    function applyArmRig(side, rig) {
      const arm = puppetArms[side];
      if (!arm || !arm.ready || !rig) return;
      const bases = arm.base || {};
      const { A, B, C } = rig;
      if (A && B && arm.upper) {
        const matrix = rotatePuppetSegment(arm.upper, A, B, side, 'upper');
        if (matrix) {
          const baseSegment = bases.upper || PUPPET_ARM_BASES?.[side]?.upper || [];
          validateSegment(`arm-${side}-upper`, baseSegment, [A, B], matrix);
        }
      }
      if (B && C && arm.lower) {
        const matrix = rotatePuppetSegment(arm.lower, B, C, side, 'lower');
        if (matrix) {
          const baseSegment = bases.lower || PUPPET_ARM_BASES?.[side]?.lower || [];
          validateSegment(`arm-${side}-lower`, baseSegment, [B, C], matrix);
        }
      }
    }

    function seg(id, stroke = '#4a8bff', width = 10) {
      const line = document.createElementNS(NS, 'line');
      line.id = id;
      line.setAttribute('stroke', stroke);
      line.setAttribute('stroke-width', width);
      line.setAttribute('stroke-linecap', 'round');
      line.classList.add('joint');
      svgEl.appendChild(line);
      return line;
    }

    function faceGuide(id, stroke = '#4a8bff', width = 6) {
      const poly = document.createElementNS(NS, 'polyline');
      poly.id = id;
      poly.setAttribute('fill', 'none');
      poly.setAttribute('stroke', stroke);
      poly.setAttribute('stroke-width', width);
      poly.setAttribute('stroke-linecap', 'round');
      poly.setAttribute('stroke-linejoin', 'round');
      poly.classList.add('joint');
      svgEl.appendChild(poly);
      return poly;
    }

    function recomputePuppetMeasurements() {
      PUPPET_SHOULDERS_MID.x = (PUPPET_LEFT_SH.x + PUPPET_RIGHT_SH.x) / 2;
      PUPPET_SHOULDERS_MID.y = (PUPPET_LEFT_SH.y + PUPPET_RIGHT_SH.y) / 2;
      PUPPET_UPPER_ARM_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_EL);
      PUPPET_LOWER_ARM_LEN = dist(PUPPET_LEFT_EL, PUPPET_LEFT_WR);
      PUPPET_RIGHT_UPPER_ARM_LEN = dist(PUPPET_RIGHT_SH, PUPPET_RIGHT_EL);
      PUPPET_RIGHT_LOWER_ARM_LEN = dist(PUPPET_RIGHT_EL, PUPPET_RIGHT_WR);
      PUPPET_HIP_SPAN = dist(PUPPET_LEFT_HIP, PUPPET_RIGHT_HIP);
      PUPPET_TORSO_CENTER_LEN = dist(
        PUPPET_SHOULDERS_MID,
        mid(PUPPET_LEFT_HIP, PUPPET_RIGHT_HIP)
      );
      PUPPET_LEFT_TORSO_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_HIP);
      PUPPET_RIGHT_TORSO_LEN = dist(PUPPET_RIGHT_SH, PUPPET_RIGHT_HIP);

      const bodySources = [
        PUPPET_RIGHT_SH,
        PUPPET_LEFT_SH,
        PUPPET_RIGHT_HIP,
        PUPPET_LEFT_HIP
      ];
      for (let i = 0; i < PUPPET_BODY_BASE.length && i < bodySources.length; i += 1) {
        const source = bodySources[i];
        const target = PUPPET_BODY_BASE[i];
        if (!source || !target) continue;
        target.x = source.x;
        target.y = source.y;
      }

      const updateArmBase = (side, start, mid, end) => {
        if (!PUPPET_ARM_BASES?.[side]) return;
        const upper = PUPPET_ARM_BASES[side].upper;
        const lower = PUPPET_ARM_BASES[side].lower;
        if (upper) {
          if (upper[0]) { upper[0].x = start.x; upper[0].y = start.y; }
          if (upper[1]) { upper[1].x = mid.x; upper[1].y = mid.y; }
        }
        if (lower) {
          if (lower[0]) { lower[0].x = mid.x; lower[0].y = mid.y; }
          if (lower[1]) { lower[1].x = end.x; lower[1].y = end.y; }
        }
      };

      updateArmBase('left', PUPPET_LEFT_SH, PUPPET_LEFT_EL, PUPPET_LEFT_WR);
      updateArmBase('right', PUPPET_RIGHT_SH, PUPPET_RIGHT_EL, PUPPET_RIGHT_WR);
    }

    function updatePuppetMeasurementsFromSkeleton() {
      const overrides = {
        leftShoulder: readPoint('leftShoulder'),
        rightShoulder: readPoint('rightShoulder'),
        leftElbow: readPoint('leftElbow'),
        rightElbow: readPoint('rightElbow'),
        leftWrist: readPoint('leftWrist'),
        rightWrist: readPoint('rightWrist'),
        leftHip: readPoint('leftHip'),
        rightHip: readPoint('rightHip')
      };

      if (overrides.leftShoulder) Object.assign(PUPPET_LEFT_SH, overrides.leftShoulder);
      if (overrides.rightShoulder) Object.assign(PUPPET_RIGHT_SH, overrides.rightShoulder);
      if (overrides.leftElbow) Object.assign(PUPPET_LEFT_EL, overrides.leftElbow);
      if (overrides.rightElbow) Object.assign(PUPPET_RIGHT_EL, overrides.rightElbow);
      if (overrides.leftWrist) Object.assign(PUPPET_LEFT_WR, overrides.leftWrist);
      if (overrides.rightWrist) Object.assign(PUPPET_RIGHT_WR, overrides.rightWrist);
      if (overrides.leftHip) Object.assign(PUPPET_LEFT_HIP, overrides.leftHip);
      if (overrides.rightHip) Object.assign(PUPPET_RIGHT_HIP, overrides.rightHip);

      recomputePuppetMeasurements();
    }

    function computeFaceAnchorAdjustments() {
      if (!faceTemplatesRoot) return;
      const deltas = [];
      for (const pair of FACE_TEMPLATE_POINT_PAIRS) {
        const base = readPoint(pair.skeleton);
        const templatePt = readTemplatePoint(pair.template);
        if (!base || !templatePt) continue;
        deltas.push({
          x: templatePt.x - base.x,
          y: templatePt.y - base.y
        });
      }
      if (!deltas.length) return;
      let sumX = 0;
      let sumY = 0;
      for (const delta of deltas) {
        sumX += delta.x;
        sumY += delta.y;
      }
      FACE_ANCHOR_ADJUST.x = sumX / deltas.length;
      FACE_ANCHOR_ADJUST.y = sumY / deltas.length;
    }

    const faceFeatureRegistry = new Map();

    function appendToFaceOverlay(element) {
      if (!element) return null;
      element.style.pointerEvents = 'none';
      if (faceOverlayLayer && faceOverlayLayer.parentNode) {
        faceOverlayLayer.appendChild(element);
      } else if (svgEl) {
        svgEl.appendChild(element);
      }
      return element;
    }

    function createBrowHandler(options = {}) {
      const template = cloneTemplateNode(options.templateId || '');
      const path = template && template.tagName?.toLowerCase() === 'path'
        ? template
        : document.createElementNS(NS, 'path');
      applyTemplateStyles(template, path, ['fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'], {
        fill: 'none',
        stroke: options.stroke || '#2C323A',
        'stroke-width': options.strokeWidth ?? 12,
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round'
      });
      appendToFaceOverlay(path);
      if (options.id && !path.id) path.id = options.id;
      const state = {
        base: Array.isArray(options.fallback)
          ? options.fallback.map((pt) => ({ x: pt.x, y: pt.y }))
          : null
      };
      return {
        el: path,
        setBase(points) {
          if (Array.isArray(points)) {
            state.base = points.map((pt) => ({ x: pt.x, y: pt.y }));
          }
        },
        update({ points }) {
          const pts = Array.isArray(points) && points.length >= 2 ? points : state.base;
          if (!pts || pts.length < 2) return;
          // Preserve the template styling while redrawing the brow to match the debug polyline.
          const data = buildSmoothPath(pts, { closed: false, tension: options.tension ?? 0.6 });
          path.setAttribute('d', data);
        }
      };
    }

    function createEyeHandler(options = {}) {
      const template = cloneTemplateNode(options.templateId || '');
      const templateShapes = template ? Array.from(template.querySelectorAll('ellipse, path')) : [];
      const eyelidSource = templateShapes[0] || null;
      const pupilSource = templateShapes[1] || null;
      const group = template && template.tagName?.toLowerCase() === 'g'
        ? template
        : document.createElementNS(NS, 'g');
      group.innerHTML = '';
      appendToFaceOverlay(group);
      if (options.id) group.id = options.id;

      const outer = document.createElementNS(NS, 'path');
      applyTemplateStyles(eyelidSource, outer, ['fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'], {
        fill: options.fill || '#FFFFFF',
        stroke: options.stroke || '#2C323A',
        'stroke-width': options.strokeWidth ?? 4,
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round'
      });
      group.appendChild(outer);

      const pupil = document.createElementNS(NS, 'circle');
      applyTemplateStyles(pupilSource, pupil, ['fill'], {
        fill: options.pupilFill || '#2C323A'
      });
      pupil.setAttribute('stroke', 'none');
      group.appendChild(pupil);

      const highlight = document.createElementNS(NS, 'circle');
      highlight.setAttribute('fill', options.highlightFill || '#FFFFFF');
      highlight.setAttribute('opacity', options.highlightOpacity ?? 0.6);
      group.appendChild(highlight);

      const state = {
        base: Array.isArray(options.fallback)
          ? options.fallback.map((pt) => ({ x: pt.x, y: pt.y }))
          : null
      };

      return {
        el: group,
        setBase(points) {
          if (Array.isArray(points)) {
            state.base = points.map((pt) => ({ x: pt.x, y: pt.y }));
          }
        },
        update({ points }) {
          const ptsRaw = Array.isArray(points) && points.length ? points : state.base;
          const pts = normalizeLoopPoints(ptsRaw || []);
          if (!Array.isArray(pts) || pts.length < 3) return;
          // Rebuild the eyelid path each frame so the cloned eye keeps the template colours but matches the guide.
          const tension = options.tension ?? 0.75;
          const pathData = buildSmoothPath(pts, { closed: true, tension });
          outer.setAttribute('d', pathData);

          const len = pts.length;
          if (len < 4) return;
          const idx = (i) => pts[(i + len) % len];
          const outerCorner = idx(0);
          const innerCorner = idx(Math.floor(len / 2));
          const topMid = mid(idx(1), idx(2));
          const bottomMid = mid(idx(len - 2), idx(len - 1));
          const eyeCenter = centroid([outerCorner, innerCorner, topMid, bottomMid]);
          const horizontal = dist(outerCorner, innerCorner);
          const vertical = dist(topMid, bottomMid);
          const scale = options.pupilScale ?? 0.22;
          const radius = clamp(Math.min(horizontal, vertical * 1.4) * scale, 0.6, 12);
          const pupilY = eyeCenter.y + vertical * 0.05;
          const openness = clamp(vertical / Math.max(horizontal, 1), 0, 1);
          pupil.setAttribute('cx', formatFloat(eyeCenter.x));
          pupil.setAttribute('cy', formatFloat(pupilY));
          pupil.setAttribute('r', formatFloat(radius));
          pupil.style.display = openness > 0.08 ? 'block' : 'none';

          const highlightRadius = radius * (options.highlightScale ?? 0.38);
          const highlightOffsetX = radius * 0.4;
          const highlightOffsetY = radius * 0.4;
          const highlightX = eyeCenter.x - highlightOffsetX;
          const highlightY = pupilY - highlightOffsetY;
          highlight.setAttribute('cx', formatFloat(highlightX));
          highlight.setAttribute('cy', formatFloat(highlightY));
          highlight.setAttribute('r', formatFloat(highlightRadius));
          highlight.style.display = openness > 0.18 && radius > 1.1 ? 'block' : 'none';
        }
      };
    }

    function createNoseHandler(options = {}) {
      const template = cloneTemplateNode(options.templateId || '');
      const group = template && template.tagName?.toLowerCase() === 'g'
        ? template
        : document.createElementNS(NS, 'g');
      group.innerHTML = '';
      appendToFaceOverlay(group);
      if (options.id) group.id = options.id;

      const bridge = document.createElementNS(NS, 'path');
      applyTemplateStyles(template, bridge, ['stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'], {
        stroke: options.stroke || '#2C323A',
        'stroke-width': options.bridgeWidth ?? 3,
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round'
      });
      bridge.setAttribute('fill', 'none');
      bridge.style.display = 'none';
      group.appendChild(bridge);

      const base = document.createElementNS(NS, 'path');
      applyTemplateStyles(template, base, ['stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'], {
        stroke: options.stroke || '#2C323A',
        'stroke-width': options.baseWidth ?? 3.8,
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round'
      });
      base.setAttribute('fill', 'none');
      base.style.display = 'none';
      group.appendChild(base);

      const state = {
        base: Array.isArray(options.fallback)
          ? options.fallback.map((pt) => ({ x: pt.x, y: pt.y }))
          : null
      };

      return {
        el: group,
        setBase(points) {
          if (Array.isArray(points)) {
            state.base = points.map((pt) => ({ x: pt.x, y: pt.y }));
          }
        },
        update({ points, part }) {
          const pts = Array.isArray(points) && points.length >= 2 ? points : state.base;
          if (!pts || pts.length < 2) return;
          // Apply the template's stroke to a freshly generated curve that follows the live guide points.
          const tension = part === 'base' ? options.baseTension ?? 0.55 : options.bridgeTension ?? 0.35;
          const data = buildSmoothPath(pts, { closed: false, tension });
          if (part === 'base') {
            base.setAttribute('d', data);
            base.style.display = 'block';
          } else {
            bridge.setAttribute('d', data);
            bridge.style.display = 'block';
          }
        }
      };
    }

    function createMouthHandler(options = {}) {
      const template = cloneTemplateNode(options.templateId || '');
      const group = template && template.tagName?.toLowerCase() === 'g'
        ? template
        : document.createElementNS(NS, 'g');
      const templatePath = template ? template.querySelector('path') : null;
      group.innerHTML = '';
      appendToFaceOverlay(group);
      if (options.id) group.id = options.id;

      const outer = document.createElementNS(NS, 'path');
      applyTemplateStyles(templatePath, outer, ['fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'], {
        fill: options.outerFill || '#DF7977',
        stroke: options.outerStroke || '#B45656',
        'stroke-width': options.outerStrokeWidth ?? 4,
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round'
      });
      group.appendChild(outer);

      const inner = document.createElementNS(NS, 'path');
      inner.setAttribute('fill', options.innerFill || '#B24848');
      inner.setAttribute('stroke', 'none');
      inner.style.opacity = options.innerOpacity ?? 0.85;
      inner.style.display = 'none';
      group.appendChild(inner);

      const baseStroke = parseFloat(outer.getAttribute('stroke-width')) || (options.outerStrokeWidth ?? 4);
      const state = {
        base: Array.isArray(options.fallback)
          ? options.fallback.map((pt) => ({ x: pt.x, y: pt.y }))
          : null
      };

      return {
        el: group,
        setBase(points) {
          if (Array.isArray(points)) {
            state.base = points.map((pt) => ({ x: pt.x, y: pt.y }));
          }
        },
        update({ points, part }) {
          const ptsRaw = Array.isArray(points) && points.length ? points : state.base;
          const pts = normalizeLoopPoints(ptsRaw || []);
          if (!Array.isArray(pts) || pts.length < 3) return;
          // Use the template colours on a path rebuilt from the pose data to keep expressions aligned with the guides.
          const tension = part === 'outer' ? options.outerTension ?? 0.6 : options.innerTension ?? 0.58;
          const data = buildSmoothPath(pts, { closed: true, tension });
          if (part === 'outer') {
            outer.setAttribute('d', data);
            const half = Math.floor(pts.length / 2);
            const upperMid = centroid(pts.slice(0, half));
            const lowerMid = centroid(pts.slice(half));
            const openness = dist(upperMid, lowerMid);
            const width = Math.max(dist(pts[0], pts[half]), 1);
            const strokeWidth = clamp((openness / Math.max(width, 1)) * baseStroke + 2, 3, 6);
            outer.setAttribute('stroke-width', formatFloat(strokeWidth));
          } else {
            inner.setAttribute('d', data);
            const area = polygonArea(pts);
            inner.style.display = area > (options.innerAreaThreshold ?? 8) ? 'block' : 'none';
          }
        }
      };
    }

    const FACE_FEATURE_FACTORIES = {
      brow: createBrowHandler,
      eye: createEyeHandler,
      nose: createNoseHandler,
      mouth: createMouthHandler
    };

    function buildFaceFeature(options = {}) {
      if (!options || !options.type) return null;
      const key = options.sharedKey || options.id || null;
      const fallback = Array.isArray(options.fallback) ? options.fallback : null;
      if (key && faceFeatureRegistry.has(key)) {
        const cached = faceFeatureRegistry.get(key);
        if (cached && typeof cached.setBase === 'function' && fallback) {
          cached.setBase(fallback);
        }
        if (cached && options.id && cached.el && !cached.el.id) {
          cached.el.id = options.id;
        }
        return cached;
      }
      const factory = FACE_FEATURE_FACTORIES[options.type];
      if (!factory) return null;
      const handler = factory(options) || null;
      if (handler && handler.el && options.id && !handler.el.id) {
        handler.el.id = options.id;
      }
      if (handler && typeof handler.setBase === 'function' && fallback) {
        handler.setBase(fallback);
      }
      if (key && handler) {
        faceFeatureRegistry.set(key, handler);
      }
      return handler;
    }

    function readPoint(id) {
      if (!svgEl) return null;
      const el = svgEl.getElementById(id);
      if (!el) return null;
      const cx = el.getAttribute('cx') ?? el.getAttribute('x') ?? el.getAttribute('x1');
      const cy = el.getAttribute('cy') ?? el.getAttribute('y') ?? el.getAttribute('y1');
      if (cx == null || cy == null) return null;
      const x = parseFloat(cx);
      const y = parseFloat(cy);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x, y };
    }

    function readTemplatePoint(id) {
      if (!faceTemplatesRoot || !id) return null;
      const el = faceTemplatesRoot.querySelector(`[id='${id}']`);
      if (!el) return null;
      const cx = el.getAttribute('cx') ?? el.getAttribute('x') ?? el.getAttribute('x1');
      const cy = el.getAttribute('cy') ?? el.getAttribute('y') ?? el.getAttribute('y1');
      if (cx == null || cy == null) return null;
      const x = parseFloat(cx);
      const y = parseFloat(cy);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x, y };
    }

    function parseStyleAttribute(value) {
      if (typeof value !== 'string') return {};
      const styles = {};
      const entries = value.split(';');
      for (const entry of entries) {
        if (!entry) continue;
        const [rawKey, rawVal] = entry.split(':');
        if (!rawKey || rawVal == null) continue;
        const key = rawKey.trim();
        const val = rawVal.trim();
        if (!key) continue;
        styles[key] = val;
      }
      return styles;
    }

    function sanitizeTemplateClone(node) {
      if (!node) return node;
      const styleAttr = node.getAttribute('style');
      if (styleAttr) {
        const styles = parseStyleAttribute(styleAttr);
        if (styles.display) delete styles.display;
        const serialized = Object.entries(styles)
          .map(([key, val]) => `${key}:${val}`)
          .join(';');
        if (serialized) node.setAttribute('style', serialized);
        else node.removeAttribute('style');
      }
      if (node.getAttribute('display') === 'none') {
        node.removeAttribute('display');
      }
      return node;
    }

    function cloneTemplateNode(id) {
      if (!svgEl || !id) return null;
      const template = svgEl.getElementById(id);
      if (!template) return null;
      const clone = template.cloneNode(true);
      sanitizeTemplateClone(clone);
      if (typeof clone.querySelectorAll === 'function') {
        const descendants = clone.querySelectorAll('*');
        for (const child of descendants) {
          sanitizeTemplateClone(child);
        }
      }
      return clone;
    }

    function applyTemplateStyles(source, target, attrs = [], fallback = {}) {
      if (!target) return;
      const styleMap = source ? parseStyleAttribute(source.getAttribute?.('style')) : {};
      for (const attr of attrs) {
        const value = source?.getAttribute ? source.getAttribute(attr) : null;
        const styleValue = styleMap?.[attr];
        const finalValue = value ?? styleValue;
        if (finalValue != null) {
          target.setAttribute(attr, finalValue);
        }
      }
      for (const [attr, value] of Object.entries(fallback)) {
        if (value == null) continue;
        if (!target.hasAttribute(attr)) {
          target.setAttribute(attr, value);
        }
      }
    }

    function setPolylinePoints(polyline, pointIds) {
      if (!polyline || !Array.isArray(pointIds)) return null;
      const pts = [];
      for (const id of pointIds) {
        const pt = readPoint(id);
        if (!pt) return null;
        pts.push(pt);
      }
      placePolyline(polyline, pts);
      return pts;
    }

    function buildSegmentMatrix(baseStart, baseEnd, targetStart, targetEnd) {
      if (!baseStart || !baseEnd || !targetStart || !targetEnd) return null;
      const baseDx = baseEnd.x - baseStart.x;
      const baseDy = baseEnd.y - baseStart.y;
      const targetDx = targetEnd.x - targetStart.x;
      const targetDy = targetEnd.y - targetStart.y;
      const baseLen = Math.hypot(baseDx, baseDy);
      const targetLen = Math.hypot(targetDx, targetDy);
      if (baseLen < 1e-6 || targetLen < 1e-6) return null;
      const scale = targetLen / baseLen;
      const baseAngle = Math.atan2(baseDy, baseDx);
      const targetAngle = Math.atan2(targetDy, targetDx);
      const angle = targetAngle - baseAngle;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const a = scale * cos;
      const b = scale * sin;
      const c = -scale * sin;
      const d = scale * cos;
      const e = targetStart.x - (a * baseStart.x + c * baseStart.y);
      const f = targetStart.y - (b * baseStart.x + d * baseStart.y);
      return { a, b, c, d, e, f };
    }

    function rotatePuppetSegment(el, origin, target, side, key) {
      if (!el || !origin || !target) return null;
      const base = puppetArms?.[side]?.base?.[key] || PUPPET_ARM_BASES?.[side]?.[key];
      if (!Array.isArray(base) || base.length < 2) return null;
      const [baseStart, baseEnd] = base;
      const matrix =
        buildSegmentMatrix(baseStart, baseEnd, origin, target) || lastArmMatrices[side][key];
      if (!matrix) return null;
      lastArmMatrices[side][key] = matrix;
      const { a, b, c, d, e, f } = matrix;
      el.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
      el.style.transform = '';
      el.style.transformOrigin = '';
      return matrix;
    }

    function alignLimbToPuppet(rawArm, lengths) {
      if (!rawArm || !lengths) return null;
      const { A, B, C } = rawArm;
      if (!A || !B || !C) return null;
      const upperDx = B.x - A.x;
      const upperDy = B.y - A.y;
      const upperLen = Math.hypot(upperDx, upperDy);
      if (upperLen < 1e-3) return null;
      const upperUnitX = upperDx / upperLen;
      const upperUnitY = upperDy / upperLen;
      const alignedB = {
        x: A.x + upperUnitX * lengths.upper,
        y: A.y + upperUnitY * lengths.upper
      };

      const lowerDx = C.x - B.x;
      const lowerDy = C.y - B.y;
      const lowerLen = Math.hypot(lowerDx, lowerDy);
      if (lowerLen < 1e-3) {
        return { A, B: alignedB, C: alignedB };
      }
      const lowerUnitX = lowerDx / lowerLen;
      const lowerUnitY = lowerDy / lowerLen;
      const alignedC = {
        x: alignedB.x + lowerUnitX * lengths.lower,
        y: alignedB.y + lowerUnitY * lengths.lower
      };

      return { A, B: alignedB, C: alignedC };
    }

    function alignSegmentToLength(origin, target, length) {
      if (!origin || !target) return null;
      const dx = target.x - origin.x;
      const dy = target.y - origin.y;
      const len = Math.hypot(dx, dy);
      if (len < 1e-3) return {
        x: origin.x,
        y: origin.y + length
      };
      const scale = length / len;
      return {
        x: origin.x + dx * scale,
        y: origin.y + dy * scale
      };
    }

    function computeTorsoRig(LSh, RSh, LH, RH, rig) {
      if (!LSh || !RSh || !LH || !RH || !rig) return null;
      const leftShoulder = toRig(LSh, rig);
      const rightShoulder = toRig(RSh, rig);
      const rawLeftHip = toRig(LH, rig);
      const rawRightHip = toRig(RH, rig);
      if (!leftShoulder || !rightShoulder || !rawLeftHip || !rawRightHip) return null;

      const topMid = mid(leftShoulder, rightShoulder);
      const rawBottomMid = mid(rawLeftHip, rawRightHip);
      const centerBottom = alignSegmentToLength(topMid, rawBottomMid, PUPPET_TORSO_CENTER_LEN) || rawBottomMid;

      const hipDirDx = rawRightHip.x - rawLeftHip.x;
      const hipDirDy = rawRightHip.y - rawLeftHip.y;
      const hipDirLen = Math.hypot(hipDirDx, hipDirDy);
      const hipDir = hipDirLen < 1e-3
        ? { x: 1, y: 0 }
        : { x: hipDirDx / hipDirLen, y: hipDirDy / hipDirLen };

      const hipHalf = PUPPET_HIP_SPAN / 2;
      const hipLeftBase = {
        x: centerBottom.x - hipDir.x * hipHalf,
        y: centerBottom.y - hipDir.y * hipHalf
      };
      const hipRightBase = {
        x: centerBottom.x + hipDir.x * hipHalf,
        y: centerBottom.y + hipDir.y * hipHalf
      };

      let leftHip = alignSegmentToLength(leftShoulder, hipLeftBase, PUPPET_LEFT_TORSO_LEN) || hipLeftBase;
      let rightHip = alignSegmentToLength(rightShoulder, hipRightBase, PUPPET_RIGHT_TORSO_LEN) || hipRightBase;

      const bottomMid = mid(leftHip, rightHip);
      const desiredBottomMid = alignSegmentToLength(topMid, bottomMid, PUPPET_TORSO_CENTER_LEN) || bottomMid;
      const correction = {
        x: desiredBottomMid.x - bottomMid.x,
        y: desiredBottomMid.y - bottomMid.y
      };

      leftHip = { x: leftHip.x + correction.x, y: leftHip.y + correction.y };
      rightHip = { x: rightHip.x + correction.x, y: rightHip.y + correction.y };

      return {
        shoulders: { left: leftShoulder, right: rightShoulder },
        hips: { left: leftHip, right: rightHip },
        centerTop: topMid,
        centerBottom: desiredBottomMid
      };
    }

    function computeArmRig(side, shoulder, elbow, wrist, rig, lengths) {
      if (!rig || !lengths) return lastArmRigs[side] || null;
      if (shoulder && elbow && wrist) {
        const raw = {
          A: toRig(shoulder, rig),
          B: toRig(elbow, rig),
          C: toRig(wrist, rig)
        };
        if (!raw.A || !raw.B || !raw.C) {
          return lastArmRigs[side] || null;
        }
        const aligned = alignLimbToPuppet(raw, lengths) || raw;
        lastArmRigs[side] = aligned;
        return aligned;
      }
      return lastArmRigs[side] || null;
    }

    function updateFaceGuides(kp, rig, anchors = {}) {
      if (!rig || !segments.face.length) return;
      let headMatrix = null;
      let contourTarget = null;
      let contourFallback = null;
      let contourAnchorIndex = -1;
      const pendingUpdates = [];
      for (const segment of segments.face) {
        const { debug, handler, handlerEl, featurePart, ids, fallback, isContour, anchorIndex } = segment;
        const points = [];
        for (let i = 0; i < ids.length; i += 1) {
          const id = ids[i];
          const raw = safeKP(kp, id);
          if (raw) {
            const mapped = toRig(raw, rig);
            if (mapped) {
              points.push(mapped);
              continue;
            }
          }
          if (fallback && fallback[i]) {
            points.push(fallback[i]);
          } else {
            points.length = 0;
            break;
          }
        }

        let target = null;
        if (points.length === ids.length) {
          placePolyline(debug, points);
          target = points;
        } else if (fallback && fallback.length) {
          placePolyline(debug, fallback);
          target = fallback;
        }

        if (isContour && !headMatrix && fallback && target && fallback.length && target.length) {
          headMatrix = computeSimilarityTransform(fallback, target);
          contourTarget = target;
          contourFallback = fallback;
          contourAnchorIndex = typeof anchorIndex === 'number' ? anchorIndex : -1;
        }

        pendingUpdates.push({
          segment,
          target
        });
      }
      if (headMatrix && contourFallback && contourTarget && headAnchorBase) {
        if (!headAnchorOffset) {
          headAnchorOffset = {
            x: headAnchorBase.x - PUPPET_SHOULDERS_MID.x,
            y: headAnchorBase.y - PUPPET_SHOULDERS_MID.y
          };
        }
        const offset = headAnchorOffset || { x: 0, y: 0 };
        let desiredAnchor = null;
        if (anchors.neck) {
          desiredAnchor = {
            x: anchors.neck.x + offset.x,
            y: anchors.neck.y + offset.y
          };
        } else if (contourTarget && contourAnchorIndex >= 0 && contourAnchorIndex < contourTarget.length) {
          desiredAnchor = contourTarget[contourAnchorIndex];
        }
        if (!desiredAnchor && contourFallback && contourAnchorIndex >= 0 && contourAnchorIndex < contourFallback.length) {
          desiredAnchor = transformPoint(lastHeadMatrix || headMatrix, contourFallback[contourAnchorIndex]);
        }
        if (desiredAnchor) {
          desiredAnchor = {
            x: desiredAnchor.x + (FACE_ANCHOR_ADJUST.x ?? 0),
            y: desiredAnchor.y + (FACE_ANCHOR_ADJUST.y ?? 0)
          };
          const currentAnchorSource = contourFallback && contourAnchorIndex >= 0 ? contourFallback[contourAnchorIndex] : headAnchorBase;
          const currentAnchor = transformPoint(headMatrix, currentAnchorSource);
          if (currentAnchor) {
            const dx = desiredAnchor.x - currentAnchor.x;
            const dy = desiredAnchor.y - currentAnchor.y;
            headMatrix = {
              ...headMatrix,
              e: headMatrix.e + dx,
              f: headMatrix.f + dy
            };
          }
        }
      }

      if (headMatrix && contourFallback && contourTarget) {
        validateSegment('face-contour', contourFallback, contourTarget, headMatrix);
      }

      for (const update of pendingUpdates) {
        const { segment, target } = update;
        const { handler, handlerEl, featurePart, fallback, ids } = segment;
        if (!handler || !target) continue;
        handler.update({
          points: target,
          part: featurePart,
          fallback,
          ids,
          element: handlerEl || handler.el || null,
          matrix: headMatrix,
          contourFallback,
          contourTarget
        });
      }

      applyHeadTransform(headMatrix);
    }

    function tick() {
      if (!frames.length) return;
      const frame = frames[frameIndex];
      const kp = frame?.keypoints;
      if (!kp) {
        frameIndex = (frameIndex + 1) % frames.length;
        requestAnimationFrame(tick);
        return;
      }

      const rig = rigFromPose(kp);
      if (!rig) {
        frameIndex = (frameIndex + 1) % frames.length;
        requestAnimationFrame(tick);
        return;
      }

      const LSh = safeKP(kp, 'leftShoulder');
      const LE = safeKP(kp, 'leftElbow');
      const LW = safeKP(kp, 'leftWrist');
      const RSh = safeKP(kp, 'rightShoulder');
      const RE = safeKP(kp, 'rightElbow');
      const RW = safeKP(kp, 'rightWrist');
      const LH = safeKP(kp, 'leftHip');
      const RH = safeKP(kp, 'rightHip');

      const leftArmRig = computeArmRig('left', LSh, LE, LW, rig, {
        upper: PUPPET_UPPER_ARM_LEN,
        lower: PUPPET_LOWER_ARM_LEN
      });
      const rightArmRig = computeArmRig('right', RSh, RE, RW, rig, {
        upper: PUPPET_RIGHT_UPPER_ARM_LEN,
        lower: PUPPET_RIGHT_LOWER_ARM_LEN
      });
      const torsoRig = computeTorsoRig(LSh, RSh, LH, RH, rig);

      if (leftArmRig) {
        const { A, B, C } = leftArmRig;
        if (armPaths.left) {
          armPaths.left.setAttribute('d', `M ${A.x} ${A.y} L ${B.x} ${B.y} L ${C.x} ${C.y}`);
        }
        placeLine(segments.left.upper, A, B);
        placeLine(segments.left.lower, B, C);
        applyArmRig('left', leftArmRig);
      }

      if (rightArmRig) {
        const { A, B, C } = rightArmRig;
        if (armPaths.right) {
          armPaths.right.setAttribute('d', `M ${A.x} ${A.y} L ${B.x} ${B.y} L ${C.x} ${C.y}`);
        }
        placeLine(segments.right.upper, A, B);
        placeLine(segments.right.lower, B, C);
        applyArmRig('right', rightArmRig);
      }

      let neckBase = null;
      if (torsoRig) {
        const { shoulders, hips, centerTop, centerBottom } = torsoRig;
        placeLine(segments.body.top, shoulders.left, shoulders.right);
        placeLine(segments.body.bottom, hips.left, hips.right);
        placeLine(segments.body.left, shoulders.left, hips.left);
        placeLine(segments.body.right, shoulders.right, hips.right);
        placeLine(segments.body.center, centerTop, centerBottom);
        let bodyMatrix = computeSimilarityTransform(PUPPET_BODY_BASE, [
          shoulders.right,
          shoulders.left,
          hips.right,
          hips.left
        ]);
        if (bodyMatrix) {
          bodyMatrix = adjustMatrixTranslation(bodyMatrix, [
            { base: PUPPET_LEFT_SH, target: shoulders.left },
            { base: PUPPET_RIGHT_SH, target: shoulders.right },
            { base: PUPPET_SHOULDERS_MID, target: centerTop }
          ]);
          validateSegment('torso', PUPPET_BODY_BASE, [
            shoulders.right,
            shoulders.left,
            hips.right,
            hips.left
          ], bodyMatrix);
        }
        applyBodyTransform(bodyMatrix);
        if (bodyMatrix) {
          neckBase = transformPoint(bodyMatrix, PUPPET_SHOULDERS_MID) || centerTop;
        } else {
          neckBase = centerTop;
        }
      } else if (LSh && RSh) {
        neckBase = toRig(mid(LSh, RSh), rig);
        applyBodyTransform(null);
      } else {
        applyBodyTransform(null);
      }

      updateFaceGuides(kp, rig, { neck: neckBase });

      frameIndex = (frameIndex + 1) % frames.length;
      requestAnimationFrame(tick);
    }

    function tryStart() {
      if (!running && svgEl && frames.length) {
        running = true;
        requestAnimationFrame(tick);
      }
    }

    fetch('../boy.svg')
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status} ao carregar boy.svg`);
        return res.text();
      })
      .then((svgMarkup) => {
        stage.innerHTML = svgMarkup;
        svgEl = stage.querySelector('svg');
        if (!svgEl) throw new Error('boy.svg não possui elemento <svg>');
        svgEl.removeAttribute('width');
        svgEl.removeAttribute('height');
        svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svgEl.style.width = '100%';
        svgEl.style.height = 'auto';
        faceTemplatesRoot = svgEl.getElementById('face_templates');
        updatePuppetMeasurementsFromSkeleton();
        if (faceTemplatesRoot) {
          computeFaceAnchorAdjustments();
        }
        headTargets = [];
        bodyTargets = [];
        const headBase = svgEl.getElementById('puppet_head_base');
        const headFront = svgEl.getElementById('puppet_head_front');
        if (headBase) headTargets.push(headBase);
        if (headFront) headTargets.push(headFront);
        lastHeadMatrix = null;
        lastBodyMatrix = null;
        lastRigMatrix = null;
        lastArmMatrices.left.upper = null;
        lastArmMatrices.left.lower = null;
        lastArmMatrices.right.upper = null;
        lastArmMatrices.right.lower = null;
        const bodyGroup = svgEl.getElementById('puppet_body');
        if (bodyGroup) bodyTargets.push(bodyGroup);
        applyBodyTransform(null);
        faceOverlayLayer = svgEl.getElementById('face_overlay_layer');
        if (!faceOverlayLayer) {
          faceOverlayLayer = document.createElementNS(NS, 'g');
          faceOverlayLayer.id = 'face_overlay_layer';
          if (headFront && headFront.parentNode) {
            headFront.parentNode.insertBefore(faceOverlayLayer, headFront);
          } else if (headBase && headBase.parentNode) {
            headBase.parentNode.insertBefore(faceOverlayLayer, headBase.nextSibling);
          } else {
            svgEl.appendChild(faceOverlayLayer);
          }
        }
        faceOverlayLayer.style.pointerEvents = 'none';
        if (faceOverlayLayer && !headTargets.includes(faceOverlayLayer)) {
          headTargets.push(faceOverlayLayer);
        }
        faceFeatureRegistry.clear();
        headAnchorBase = null;
        headAnchorOffset = null;
        const skel = svgEl.getElementById('skeleton_1_');
        if (skel) skel.style.display = 'none';
        armPaths.left = document.createElementNS(NS, 'path');
        armPaths.left.id = 'L_arm_path';
        armPaths.left.setAttribute('fill', 'none');
        armPaths.left.setAttribute('stroke', '#4a8bff');
        armPaths.left.setAttribute('stroke-width', '18');
        armPaths.left.setAttribute('stroke-linecap', 'round');
        armPaths.left.setAttribute('stroke-linejoin', 'round');
        svgEl.appendChild(armPaths.left);

        armPaths.right = document.createElementNS(NS, 'path');
        armPaths.right.id = 'R_arm_path';
        armPaths.right.setAttribute('fill', 'none');
        armPaths.right.setAttribute('stroke', '#4a8bff');
        armPaths.right.setAttribute('stroke-width', '18');
        armPaths.right.setAttribute('stroke-linecap', 'round');
        armPaths.right.setAttribute('stroke-linejoin', 'round');
        svgEl.appendChild(armPaths.right);
        segments.left.upper = seg('L_upper');
        segments.left.lower = seg('L_lower');
        segments.right.upper = seg('R_upper');
        segments.right.lower = seg('R_lower');
        segments.body.top = seg('body_top', '#4a8bff', 12);
        segments.body.bottom = seg('body_bottom', '#4a8bff', 12);
        segments.body.left = seg('body_left', '#4a8bff', 12);
        segments.body.right = seg('body_right', '#4a8bff', 12);
        segments.body.center = seg('body_center', '#4a8bff', 10);

        const faceGuides = [
          {
            id: 'face_contour',
            isContour: true,
            ids: [
              'topMid', 'rightTop0', 'rightTop1', 'rightJaw0', 'rightJaw1', 'rightJaw2',
              'rightJaw3', 'rightJaw4', 'rightJaw5', 'rightJaw6', 'rightJaw7', 'jawMid',
              'leftJaw7', 'leftJaw6', 'leftJaw5', 'leftJaw4', 'leftJaw3', 'leftJaw2',
              'leftJaw1', 'leftJaw0', 'leftTop1', 'leftTop0', 'topMid'
            ],
            width: 8
          },
          {
            id: 'face_brow_right',
            ids: ['rightBrow0', 'rightBrow1', 'rightBrow2', 'rightBrow3', 'rightBrow4'],
            feature: {
              type: 'brow',
              id: 'brow_right_feature',
              sharedKey: 'brow_right',
              strokeWidth: 12,
              tension: 0.58,
              templateId: 'template_brow_right'
            }
          },
          {
            id: 'face_brow_left',
            ids: ['leftBrow0', 'leftBrow1', 'leftBrow2', 'leftBrow3', 'leftBrow4'],
            feature: {
              type: 'brow',
              id: 'brow_left_feature',
              sharedKey: 'brow_left',
              strokeWidth: 12,
              tension: 0.58,
              templateId: 'template_brow_left'
            }
          },
          {
            id: 'face_eye_right',
            ids: ['rightEye0', 'rightEye1', 'rightEye2', 'rightEye3', 'rightEye4', 'rightEye5', 'rightEye0'],
            width: 5,
            feature: {
              type: 'eye',
              id: 'eye_right_feature',
              sharedKey: 'eye_right',
              side: 'right',
              strokeWidth: 4,
              templateId: 'template_eye_right'
            }
          },
          {
            id: 'face_eye_left',
            ids: ['leftEye0', 'leftEye1', 'leftEye2', 'leftEye3', 'leftEye4', 'leftEye5', 'leftEye0'],
            width: 5,
            feature: {
              type: 'eye',
              id: 'eye_left_feature',
              sharedKey: 'eye_left',
              side: 'left',
              strokeWidth: 4,
              templateId: 'template_eye_left'
            }
          },
          {
            id: 'face_nose_bridge',
            ids: ['nose0', 'nose1', 'nose2', 'nose3', 'nose4'],
            feature: {
              type: 'nose',
              id: 'nose_feature',
              sharedKey: 'nose',
              part: 'bridge',
              stroke: '#2C323A',
              templateId: 'template_nose'
            }
          },
          {
            id: 'face_nose_base',
            ids: ['rightNose0', 'rightNose1', 'nose4', 'leftNose1', 'leftNose0'],
            width: 5,
            feature: {
              type: 'nose',
              id: 'nose_feature',
              sharedKey: 'nose',
              part: 'base',
              stroke: '#2C323A',
              templateId: 'template_nose'
            }
          },
          {
            id: 'face_mouth_outer',
            ids: [
              'rightMouthCorner', 'rightUpperLipTop0', 'rightUpperLipTop1', 'upperLipTopMid',
              'leftUpperLipTop1', 'leftUpperLipTop0', 'leftMouthCorner', 'leftLowerLipBottom0',
              'leftLowerLipBottom1', 'lowerLipBottomMid', 'rightLowerLipBottom1', 'rightLowerLipBottom0',
              'rightMouthCorner'
            ],
            width: 7,
            feature: {
              type: 'mouth',
              id: 'mouth_feature',
              sharedKey: 'mouth',
              part: 'outer',
              templateId: 'template_mouth'
            }
          },
          {
            id: 'face_mouth_inner',
            ids: [
              'rightMouthCorner', 'rightUpperLipBottom1', 'upperLipBottomMid', 'leftUpperLipBottom1',
              'leftMouthCorner', 'leftLowerLipTop0', 'lowerLipTopMid', 'rightLowerLipTop0', 'rightMouthCorner'
            ],
            width: 4,
            feature: {
              type: 'mouth',
              sharedKey: 'mouth',
              part: 'inner',
              templateId: 'template_mouth'
            }
          }
        ];

        for (const guide of faceGuides) {
          const debug = faceGuide(guide.id, '#4a8bff', guide.width ?? 6);
          const fallbackPoints = setPolylinePoints(debug, guide.ids);
          if (!fallbackPoints) {
            console.warn(`Não foi possível construir a linha de rosto ${guide.id}`);
            debug.remove();
            continue;
          }
          const fallback = fallbackPoints.map((pt) => ({ x: pt.x, y: pt.y }));
          placePolyline(debug, fallback);

          let handler = null;
          let handlerEl = null;
          let featurePart = null;
          if (guide.feature) {
            handler = buildFaceFeature({ ...guide.feature, fallback });
            handlerEl = handler?.el || null;
            featurePart = guide.feature.part ?? null;
            if (handler && typeof handler.update === 'function') {
              handler.update({
                points: fallback,
                part: featurePart,
                fallback,
                ids: guide.ids,
                element: handlerEl,
                matrix: null
              });
            }
          }

          const anchorIndex = guide.isContour ? guide.ids.indexOf(HEAD_ANCHOR_ID) : -1;
          segments.face.push({
            debug,
            handler,
            handlerEl,
            featurePart,
            ids: guide.ids,
            fallback,
            isContour: Boolean(guide.isContour),
            anchorIndex
          });

          if (guide.isContour && anchorIndex >= 0 && fallback[anchorIndex]) {
            headAnchorBase = {
              x: fallback[anchorIndex].x,
              y: fallback[anchorIndex].y
            };
            headAnchorOffset = null;
          }
        }

        const armCandidates = {
          left: {
            upper: [
              'leftUpperArm',
              'LeftUpperArm',
              'left_upper_arm',
              'Left_arm_upper',
              'leftArmUpper',
              'leftupperarm',
              'leftArm_Upper'
            ],
            lower: [
              'leftLowerArm',
              'LeftLowerArm',
              'left_lower_arm',
              'Left_arm_lower',
              'leftArmLower',
              'leftlowerarm',
              'leftArm_Lower'
            ]
          },
          right: {
            upper: [
              'rightUpperArm',
              'RightUpperArm',
              'right_upper_arm',
              'Right_arm_upper',
              'rightArmUpper',
              'rightupperarm',
              'rightArm_Upper'
            ],
            lower: [
              'rightLowerArm',
              'RightLowerArm',
              'right_lower_arm',
              'Right_arm_lower',
              'rightArmLower',
              'rightlowerarm',
              'rightArm_Lower'
            ]
          }
        };

        const findArmPart = (candidates) => {
          for (const id of candidates) {
            const el = svgEl.getElementById(id);
            if (el) return el;
          }
          return null;
        };

        const setupArmPart = (side) => {
          const candidates = armCandidates[side];
          const upper = findArmPart(candidates.upper);
          const lower = findArmPart(candidates.lower);
          puppetArms[side].upper = upper;
          puppetArms[side].lower = lower;
          const ready = ensurePuppetArm(side);
          puppetArms[side].ready = ready;

          if (!ready && !puppetArms[side].warningShown) {
            const sideLabel = side === 'left' ? 'esquerdo' : 'direito';
            console.warn(`Braço ${sideLabel} do puppet não encontrado em boy.svg; mantendo modo debug.`);
            puppetArms[side].warningShown = true;
          }

          const attach = (el) => {
            if (!el) return;
            el.style.transformBox = 'fill-box';
            el.classList.add('joint');
            el.removeAttribute('transform');
            el.style.transform = '';
            el.style.transformOrigin = '';
            if (el.parentNode) {
              el.parentNode.appendChild(el);
            }
          };

          attach(upper);
          attach(lower);
        };

        setupArmPart('left');
        setupArmPart('right');

        updateVisibility();
        tryStart();
      })
      .catch((err) => {
        console.error(err);
        showError('Erro ao carregar boy.svg: ' + err.message);
      });

    fetch('pose_frames.json')
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status} ao carregar pose_frames.json`);
        return res.json();
      })
      .then((data) => {
        if (!Array.isArray(data) || !data.length) {
          throw new Error('Arquivo pose_frames.json vazio ou inválido.');
        }
        frames = data;
        tryStart();
      })
      .catch((err) => {
        console.error(err);
        showError('Erro ao carregar pose_frames.json: ' + err.message);
      });

    const toggleButtons = Array.from(document.querySelectorAll('[data-toggle-target]'));
    toggleButtons.forEach((button) => {
      const target = button.dataset.toggleTarget;
      if (!target || !(target in debugToggles)) return;
      button.classList.toggle('inactive', !debugToggles[target]);
      button.setAttribute('aria-pressed', String(debugToggles[target]));
      button.addEventListener('click', () => {
        debugToggles[target] = !debugToggles[target];
        button.classList.toggle('inactive', !debugToggles[target]);
        button.setAttribute('aria-pressed', String(debugToggles[target]));
        updateVisibility();
      });
    });
  </script>
</body>
</html>
