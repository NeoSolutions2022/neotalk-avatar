<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>Avatar por pose</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 25% 25%, #ffffff 0, #f6f8fc 45%, #e6ecfb 100%);
      color: #1f2a44;
    }

    h1 {
      font-size: 1.6rem;
      margin: 0;
    }

    #info {
      font-size: 0.95rem;
      opacity: 0.75;
    }

    main {
      width: min(560px, 92vw);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #stage {
      width: 100%;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 16px;
      box-shadow: 0 12px 32px rgba(30, 70, 140, 0.12);
      padding: clamp(12px, 3vw, 28px);
    }

    #stage svg {
      width: 100%;
      height: auto;
      display: block;
    }

    #debugControls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      justify-content: center;
      background: rgba(74, 139, 255, 0.08);
      border-radius: 999px;
      padding: 0.6rem 1rem;
      border: 1px solid rgba(74, 139, 255, 0.18);
    }

    #debugControls span {
      font-weight: 600;
      font-size: 0.9rem;
      letter-spacing: 0.01em;
    }

    .debug-toggle {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      font-weight: 600;
      color: #1f2a44;
      background: rgba(74, 139, 255, 0.18);
      cursor: pointer;
      transition: background 120ms ease, color 120ms ease, box-shadow 120ms ease;
      box-shadow: inset 0 0 0 1px rgba(74, 139, 255, 0.1);
    }

    .debug-toggle:hover {
      background: rgba(74, 139, 255, 0.28);
    }

    .debug-toggle.inactive {
      background: rgba(125, 139, 166, 0.14);
      color: rgba(31, 42, 68, 0.6);
      box-shadow: inset 0 0 0 1px rgba(125, 139, 166, 0.18);
    }

    #playbackControls {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      background: rgba(74, 139, 255, 0.08);
      border-radius: 12px;
      padding: 0.55rem 0.9rem;
      border: 1px solid rgba(74, 139, 255, 0.18);
    }

    #playbackControls label {
      font-weight: 600;
      font-size: 0.9rem;
    }

    #speedControl {
      width: min(220px, 45vw);
    }

    #speedValue {
      font-weight: 600;
      min-width: 3ch;
      text-align: right;
    }

    .joint {
      transform-box: fill-box;
      transform-origin: center;
      transition: transform 60ms linear;
    }

    #L_upper,
    #L_lower,
    #R_upper,
    #R_lower {
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.15));
    }

    #error {
      position: fixed;
      bottom: 1.2rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(220, 53, 69, 0.92);
      color: #fff;
      padding: 0.8rem 1.2rem;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
      display: none;
      max-width: min(480px, 90vw);
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Avatar 2D animado por <code>.pose</code></h1>
  <div id="info">Animando a partir de <code>pose_frames.json</code></div>
  <main>
    <div id="stage" aria-live="polite"></div>
  </main>
  <section id="debugControls" aria-label="Alternar linhas de debug">
    <span>Linhas de debug:</span>
    <button type="button" class="debug-toggle" data-toggle-target="leftArm" aria-pressed="true">Braço esquerdo</button>
    <button type="button" class="debug-toggle" data-toggle-target="rightArm" aria-pressed="true">Braço direito</button>
    <button type="button" class="debug-toggle" data-toggle-target="body" aria-pressed="true">Corpo</button>
    <button type="button" class="debug-toggle" data-toggle-target="face" aria-pressed="true">Rosto</button>
    <button type="button" class="debug-toggle" data-toggle-target="faceOverlay" aria-pressed="true">Face (overlay)</button>
    <button type="button" class="debug-toggle" data-toggle-target="fingers" aria-pressed="true">Dedos</button>
  </section>
  <section id="playbackControls" aria-label="Controle de velocidade da animação">
    <label for="speedControl">Velocidade:</label>
    <input type="range" id="speedControl" min="0" max="2.5" step="0.05" value="1" />
    <output id="speedValue" for="speedControl">1×</output>
  </section>
  <div id="error" role="alert"></div>
  <script>
    const stage = document.getElementById('stage');
    const errorBox = document.getElementById('error');
    const speedControl = document.getElementById('speedControl');
    const speedValue = document.getElementById('speedValue');
    const NS = 'http://www.w3.org/2000/svg';

    const DEFAULT_PLAYBACK_SPEED = 1;
    const DEFAULT_FPS = 30;
    const BASE_FRAME_DURATION = 1000 / DEFAULT_FPS;

    const showError = (msg) => {
      errorBox.textContent = msg;
      errorBox.style.display = 'block';
    };

    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    const mid = (a, b) => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 });
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const formatFloat = (value) => {
      if (!Number.isFinite(value)) return '0';
      const fixed = Number(value).toFixed(2);
      const trimmed = fixed.replace(/\.0+$/, '').replace(/(\.\d+?)0+$/, '$1');
      return trimmed === '-0' ? '0' : trimmed;
    };

    const escapeSelector = (value) => {
      if (typeof value !== 'string') return value;
      if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') {
        return CSS.escape(value);
      }
      return value.replace(/([\0-\x1F\x7F-\x9F\s#.:?%&,+*~\[\]()>@{}|\\^$])/g, '\\$1');
    };

    function midpoint(p, q) {
      if (!p || !q) return null;
      return { x: (p.x + q.x) / 2, y: (p.y + q.y) / 2 };
    }

    function similarityFrom2Points(baseA, baseB, liveA, liveB) {
      if (!baseA || !baseB || !liveA || !liveB) return null;
      const baseDx = baseB.x - baseA.x;
      const baseDy = baseB.y - baseA.y;
      const liveDx = liveB.x - liveA.x;
      const liveDy = liveB.y - liveA.y;
      const baseLen = Math.hypot(baseDx, baseDy);
      const liveLen = Math.hypot(liveDx, liveDy);
      if (baseLen < 1e-6 || liveLen < 1e-6) return null;
      const baseUx = baseDx / baseLen;
      const baseUy = baseDy / baseLen;
      const liveUx = liveDx / liveLen;
      const liveUy = liveDy / liveLen;
      const cos = baseUx * liveUx + baseUy * liveUy;
      const sin = baseUx * liveUy - baseUy * liveUx;
      const scale = liveLen / baseLen;
      const a = scale * cos;
      const b = scale * sin;
      const c = -scale * sin;
      const d = scale * cos;
      const e = liveA.x - (a * baseA.x + c * baseA.y);
      const f = liveA.y - (b * baseA.x + d * baseA.y);
      if ([a, b, c, d, e, f].some((value) => !Number.isFinite(value))) return null;
      return { a, b, c, d, e, f };
    }

    function applyMatrixToElement(el, matrix) {
      if (!el) return;
      if (matrix) {
        const { a, b, c, d, e, f } = matrix;
        el.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
      } else {
        el.removeAttribute('transform');
      }
    }

    function updateSpeedIndicator(value = playbackSpeed) {
      if (!speedValue) return;
      const formatted = formatFloat(value ?? playbackSpeed);
      speedValue.textContent = `${formatted}×`;
    }

    function normalizeLoopPoints(points) {
      if (!Array.isArray(points) || points.length < 2) return points || [];
      const first = points[0];
      const last = points[points.length - 1];
      if (!first || !last) return points;
      if (Math.hypot(first.x - last.x, first.y - last.y) < 1e-3) {
        return points.slice(0, -1);
      }
      return points;
    }

    function centroid(points) {
      if (!Array.isArray(points) || !points.length) return { x: 0, y: 0 };
      let sumX = 0;
      let sumY = 0;
      for (const pt of points) {
        sumX += pt.x;
        sumY += pt.y;
      }
      const count = points.length;
      return { x: sumX / count, y: sumY / count };
    }

    function polygonArea(points) {
      if (!Array.isArray(points) || points.length < 3) return 0;
      let area = 0;
      const len = points.length;
      for (let i = 0; i < len; i += 1) {
        const p0 = points[i];
        const p1 = points[(i + 1) % len];
        area += p0.x * p1.y - p1.x * p0.y;
      }
      return Math.abs(area / 2);
    }

    function buildSmoothPath(points, { closed = false, tension = 0.5 } = {}) {
      if (!Array.isArray(points) || points.length < 2) return '';
      const pts = points.slice();
      if (pts.length === 2) {
        const [start, end] = pts;
        return `M ${formatFloat(start.x)} ${formatFloat(start.y)} L ${formatFloat(end.x)} ${formatFloat(end.y)}`;
      }

      const len = pts.length;
      const safeTension = clamp(tension, 0, 1);
      const getPoint = (idx) => {
        if (closed) {
          const wrapped = (idx % len + len) % len;
          return pts[wrapped];
        }
        if (idx < 0) return pts[0];
        if (idx >= len) return pts[len - 1];
        return pts[idx];
      };

      let path = `M ${formatFloat(pts[0].x)} ${formatFloat(pts[0].y)}`;
      const segments = closed ? len : len - 1;
      for (let i = 0; i < segments; i += 1) {
        const p0 = getPoint(i - 1);
        const p1 = getPoint(i);
        const p2 = getPoint(i + 1);
        const p3 = getPoint(i + 2);
        if (!p1 || !p2 || !p0 || !p3) continue;
        const c1x = p1.x + (p2.x - p0.x) * (safeTension / 6);
        const c1y = p1.y + (p2.y - p0.y) * (safeTension / 6);
        const c2x = p2.x - (p3.x - p1.x) * (safeTension / 6);
        const c2y = p2.y - (p3.y - p1.y) * (safeTension / 6);
        path += ` C ${formatFloat(c1x)} ${formatFloat(c1y)} ${formatFloat(c2x)} ${formatFloat(c2y)} ${formatFloat(p2.x)} ${formatFloat(p2.y)}`;
      }
      if (closed) path += ' Z';
      return path;
    }

    function parseHexColor(hex) {
      if (typeof hex !== 'string') return null;
      const match = hex.trim().match(/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i);
      if (!match) return null;
      let value = match[1];
      if (value.length === 3) {
        value = value.split('').map((ch) => ch + ch).join('');
      }
      const int = Number.parseInt(value, 16);
      if (!Number.isFinite(int)) return null;
      return {
        r: (int >> 16) & 255,
        g: (int >> 8) & 255,
        b: int & 255
      };
    }

    function rgbToHex({ r, g, b } = {}) {
      if (!Number.isFinite(r) || !Number.isFinite(g) || !Number.isFinite(b)) return null;
      const toHex = (component) => {
        const clamped = clamp(Math.round(component), 0, 255);
        return clamped.toString(16).padStart(2, '0');
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function mixRgb(a, b, t = 0.5) {
      if (!a || !b) return a || b;
      const ratio = clamp(Number.isFinite(t) ? t : 0.5, 0, 1);
      return {
        r: a.r + (b.r - a.r) * ratio,
        g: a.g + (b.g - a.g) * ratio,
        b: a.b + (b.b - a.b) * ratio
      };
    }

    function mixHex(colorA, colorB, t = 0.5) {
      const a = parseHexColor(colorA);
      const b = parseHexColor(colorB);
      if (!a || !b) return colorA;
      const mixed = mixRgb(a, b, t);
      const hex = rgbToHex(mixed);
      return hex || colorA;
    }

    const PUPPET_LEFT_SH = { x: 605.7, y: 294.3 };
    const PUPPET_RIGHT_SH = { x: 392.8, y: 294.3 };
    const PUPPET_LEFT_EL = { x: 710.1, y: 294.0 };
    const PUPPET_LEFT_WR = { x: 873.5, y: 300.3 };
    const PUPPET_RIGHT_EL = { x: 289.3, y: 294.4 };
    const PUPPET_RIGHT_WR = { x: 125.9, y: 300.8 };
    const PUPPET_SHOULDERS_MID = {
      x: (PUPPET_LEFT_SH.x + PUPPET_RIGHT_SH.x) / 2,
      y: PUPPET_LEFT_SH.y
    };
    let PUPPET_UPPER_ARM_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_EL);
    let PUPPET_LOWER_ARM_LEN = dist(PUPPET_LEFT_EL, PUPPET_LEFT_WR);
    let PUPPET_RIGHT_UPPER_ARM_LEN = dist(PUPPET_RIGHT_SH, PUPPET_RIGHT_EL);
    let PUPPET_RIGHT_LOWER_ARM_LEN = dist(PUPPET_RIGHT_EL, PUPPET_RIGHT_WR);
    const PUPPET_LEFT_HIP = { x: 559.5, y: 509.3 };
    const PUPPET_RIGHT_HIP = { x: 443.1, y: 510.1 };
    let PUPPET_HIP_SPAN = dist(PUPPET_LEFT_HIP, PUPPET_RIGHT_HIP);
    let PUPPET_TORSO_CENTER_LEN = dist(
      PUPPET_SHOULDERS_MID,
      mid(PUPPET_LEFT_HIP, PUPPET_RIGHT_HIP)
    );
    let PUPPET_LEFT_TORSO_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_HIP);
    let PUPPET_RIGHT_TORSO_LEN = dist(PUPPET_RIGHT_SH, PUPPET_RIGHT_HIP);
    const PUPPET_BODY_BASE = [
      { ...PUPPET_RIGHT_SH },
      { ...PUPPET_LEFT_SH },
      { ...PUPPET_RIGHT_HIP },
      { ...PUPPET_LEFT_HIP }
    ];
    const torsoRigState = {
      node: null,
      base: {
        leftShoulder: null,
        rightShoulder: null,
        leftHip: null,
        rightHip: null
      },
      ready: false,
      lastMatrix: null,
      lastNeckAnchor: null
    };
    const TORSO_NECK_OFFSET = { x: 0, y: -20 };
    let lastNeckAnchorLogged = null;
    const PUPPET_ARM_BASES = {
      left: {
        upper: [{ ...PUPPET_LEFT_SH }, { ...PUPPET_LEFT_EL }],
        lower: [{ ...PUPPET_LEFT_EL }, { ...PUPPET_LEFT_WR }]
      },
      right: {
        upper: [{ ...PUPPET_RIGHT_SH }, { ...PUPPET_RIGHT_EL }],
        lower: [{ ...PUPPET_RIGHT_EL }, { ...PUPPET_RIGHT_WR }]
      }
    };

    const DEBUG_ARM = new URLSearchParams(window.location.search).get('debugArm') !== '0';
    const smooth = {};
    const debugToggles = {
      leftArm: DEBUG_ARM,
      rightArm: DEBUG_ARM,
      body: true,
      face: true,
      faceOverlay: true,
      fingers: true
    };
    const FACE_OVERLAY_ID = 'faceSynth';
    const LEGACY_FACE_OVERLAY_ID = 'face_overlay_layer';
    const FACE_OVERLAY_SUBGROUP_IDS = {
      skin: 'fs-skin',
      mouth: 'fs-mouth',
      nose: 'fs-nose',
      eyes: 'fs-eyes',
      brows: 'fs-brows'
    };
    let faceTemplatesRoot = null;
    let faceOverlayLayer = null;
    const faceOverlayGroups = new Map();
    let headTargets = [];
    let bodyTargets = [];
    let lastHeadMatrix = null;
    let lastBodyMatrix = null;
    let lastRigMatrix = null;
    const HEAD_ANCHOR_ID = 'jawMid';
    const FACE_ANCHOR_ADJUST = { x: 0, y: 6 };
    const FACE_TEMPLATE_POINT_PAIRS = [
      { skeleton: 'upperLipBottomMid', template: 'upperLipBottomMid_1_' },
      { skeleton: 'lowerLipTopMid', template: 'lowerLipTopMid_2_' },
      { skeleton: 'rightEye0', template: 'rightEye0_1_' },
      { skeleton: 'leftEye0', template: 'leftEye0_1_' },
      { skeleton: 'nose4', template: 'nose4_1_' },
      { skeleton: 'rightBrow2', template: 'rightBrow2_1_' },
      { skeleton: 'leftBrow2', template: 'leftBrow2_1_' }
    ];
    let headAnchorBase = null;
    let headAnchorOffset = null;
    const VALIDATION_TOLERANCE = 12;
    const validationNotified = new Set();

    const HAND_PALM_CHAIN = [0, 5, 9, 13, 17, 0];
    const HAND_FINGER_CHAINS = {
      thumb: [0, 1, 2, 3, 4],
      index: [0, 5, 6, 7, 8],
      middle: [0, 9, 10, 11, 12],
      ring: [0, 13, 14, 15, 16],
      pinky: [0, 17, 18, 19, 20]
    };
    const HAND_SIDE_KEYS = {
      left: [
        'left',
        'leftHand',
        'left_hand',
        'handLeft',
        'leftHandLandmarks',
        'leftLandmarks',
        'leftPalm'
      ],
      right: [
        'right',
        'rightHand',
        'right_hand',
        'handRight',
        'rightHandLandmarks',
        'rightLandmarks',
        'rightPalm'
      ]
    };
    const HAND_LANDMARK_ALIASES = {
      0: ['WRIST'],
      1: ['THUMB_CMC', 'THUMB0', 'THUMB_CARPAL', 'THUMB_BASE'],
      2: ['THUMB_MCP', 'THUMB1'],
      3: ['THUMB_IP', 'THUMB2'],
      4: ['THUMB_TIP', 'THUMB3'],
      5: ['INDEX_FINGER_MCP', 'INDEX0', 'INDEX_BASE'],
      6: ['INDEX_FINGER_PIP', 'INDEX1'],
      7: ['INDEX_FINGER_DIP', 'INDEX2'],
      8: ['INDEX_FINGER_TIP', 'INDEX3'],
      9: ['MIDDLE_FINGER_MCP', 'MIDDLE0', 'MIDDLE_BASE'],
      10: ['MIDDLE_FINGER_PIP', 'MIDDLE1'],
      11: ['MIDDLE_FINGER_DIP', 'MIDDLE2'],
      12: ['MIDDLE_FINGER_TIP', 'MIDDLE3'],
      13: ['RING_FINGER_MCP', 'RING0', 'RING_BASE'],
      14: ['RING_FINGER_PIP', 'RING1'],
      15: ['RING_FINGER_DIP', 'RING2'],
      16: ['RING_FINGER_TIP', 'RING3'],
      17: ['PINKY_MCP', 'PINKY0', 'PINKY_BASE', 'LITTLE0'],
      18: ['PINKY_PIP', 'PINKY1', 'LITTLE1'],
      19: ['PINKY_DIP', 'PINKY2', 'LITTLE2'],
      20: ['PINKY_TIP', 'PINKY3', 'LITTLE3']
    };
    const HAND_SMOOTH_ALPHA = 0.45;
    const FINGER_CAPSULE_WIDTHS = {
      thumb: 26,
      index: 20,
      middle: 22,
      ring: 20,
      pinky: 18
    };
    const HAND_KEYPOINT_NAME_MAP = {
      left: {
        0: ['leftWrist'],
        1: ['leftThumbCMC', 'leftThumb0', 'leftThumb1'],
        2: ['leftThumbMCP', 'leftThumb2'],
        3: ['leftThumbIP', 'leftThumb3'],
        4: ['leftThumbTip', 'leftThumb4'],
        5: ['leftIndexMCP', 'leftIndex0'],
        6: ['leftIndexPIP', 'leftIndex1'],
        7: ['leftIndexDIP', 'leftIndex2'],
        8: ['leftIndexTip', 'leftIndex3'],
        9: ['leftMiddleMCP', 'leftMiddle0'],
        10: ['leftMiddlePIP', 'leftMiddle1'],
        11: ['leftMiddleDIP', 'leftMiddle2'],
        12: ['leftMiddleTip', 'leftMiddle3'],
        13: ['leftRingMCP', 'leftRing0'],
        14: ['leftRingPIP', 'leftRing1'],
        15: ['leftRingDIP', 'leftRing2'],
        16: ['leftRingTip', 'leftRing3'],
        17: ['leftPinkyMCP', 'leftPinky0', 'leftLittle0'],
        18: ['leftPinkyPIP', 'leftPinky1', 'leftLittle1'],
        19: ['leftPinkyDIP', 'leftPinky2', 'leftLittle2'],
        20: ['leftPinkyTip', 'leftPinky3', 'leftLittle3']
      },
      right: {
        0: ['rightWrist'],
        1: ['rightThumbCMC', 'rightThumb0', 'rightThumb1'],
        2: ['rightThumbMCP', 'rightThumb2'],
        3: ['rightThumbIP', 'rightThumb3'],
        4: ['rightThumbTip', 'rightThumb4'],
        5: ['rightIndexMCP', 'rightIndex0'],
        6: ['rightIndexPIP', 'rightIndex1'],
        7: ['rightIndexDIP', 'rightIndex2'],
        8: ['rightIndexTip', 'rightIndex3'],
        9: ['rightMiddleMCP', 'rightMiddle0'],
        10: ['rightMiddlePIP', 'rightMiddle1'],
        11: ['rightMiddleDIP', 'rightMiddle2'],
        12: ['rightMiddleTip', 'rightMiddle3'],
        13: ['rightRingMCP', 'rightRing0'],
        14: ['rightRingPIP', 'rightRing1'],
        15: ['rightRingDIP', 'rightRing2'],
        16: ['rightRingTip', 'rightRing3'],
        17: ['rightPinkyMCP', 'rightPinky0', 'rightLittle0'],
        18: ['rightPinkyPIP', 'rightPinky1', 'rightLittle1'],
        19: ['rightPinkyDIP', 'rightPinky2', 'rightLittle2'],
        20: ['rightPinkyTip', 'rightPinky3', 'rightLittle3']
      }
    };

    const EMA = (prev, cur, a = 0.35) => {
      if (!prev) return cur;
      return {
        x: prev.x + a * (cur.x - prev.x),
        y: prev.y + a * (cur.y - prev.y)
      };
    };

    const smoothScalar = (prev, next, alpha = 0.35) => {
      if (!Number.isFinite(next)) return prev ?? 0;
      if (prev == null) return next;
      return prev + alpha * (next - prev);
    };

    const smoothAngle = (prev, next, alpha = 0.3) => {
      if (!Number.isFinite(next)) return prev ?? 0;
      if (prev == null) return next;
      const delta = Math.atan2(Math.sin(next - prev), Math.cos(next - prev));
      return prev + alpha * delta;
    };

    function safeKP(kp, name) {
      const prev = smooth[name] ?? null;
      const raw = kp?.[name] ?? null;
      let next = null;
      if (raw && prev) next = EMA(prev, raw);
      else next = raw || prev || null;
      smooth[name] = next;
      return next;
    }

    function rigFromPose(kp) {
      const LSh = safeKP(kp, 'leftShoulder');
      const RSh = safeKP(kp, 'rightShoulder');
      if (!LSh || !RSh) return lastRigMatrix;
      const matrix = computeSimilarityTransform(
        [RSh, LSh],
        [PUPPET_RIGHT_SH, PUPPET_LEFT_SH]
      );
      if (!matrix) return lastRigMatrix;
      lastRigMatrix = matrix;
      return matrix;
    }

    const toRig = (p, rig) => {
      if (!rig || !p) return null;
      const { a, b, c, d, e, f } = rig;
      return {
        x: a * p.x + c * p.y + e,
        y: b * p.x + d * p.y + f
      };
    };

    const transformPoint = (matrix, point) => {
      if (!matrix || !point) return null;
      const { a, b, c, d, e, f } = matrix;
      return {
        x: a * point.x + c * point.y + e,
        y: b * point.x + d * point.y + f
      };
    };

    function parseDataPoint(value) {
      if (typeof value !== 'string') return null;
      const parts = value.split(',');
      if (parts.length < 2) return null;
      const x = Number.parseFloat(parts[0]);
      const y = Number.parseFloat(parts[1]);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x, y };
    }

    function ensureTorso(svg = svgEl) {
      const context = svg || svgEl;
      if (!context) return null;
      if (!torsoRigState.node) {
        torsoRigState.node = context.getElementById ? context.getElementById('torso') : null;
      }
      const node = torsoRigState.node;
      if (!node) {
        torsoRigState.ready = false;
        return null;
      }
      const dataset = node.dataset || {};
      const basePoints = {
        leftShoulder: parseDataPoint(dataset.leftShoulder),
        rightShoulder: parseDataPoint(dataset.rightShoulder),
        leftHip: parseDataPoint(dataset.leftHip),
        rightHip: parseDataPoint(dataset.rightHip)
      };
      const ready = Object.values(basePoints).every(Boolean);
      if (ready) {
        torsoRigState.base = basePoints;
        torsoRigState.ready = true;
        return torsoRigState;
      }
      torsoRigState.ready = false;
      return null;
    }

    function logNeckAnchor(anchor) {
      if (!anchor) return;
      if (lastNeckAnchorLogged) {
        const delta = Math.hypot(
          anchor.x - lastNeckAnchorLogged.x,
          anchor.y - lastNeckAnchorLogged.y
        );
        if (delta < 0.5) return;
      }
      lastNeckAnchorLogged = { x: anchor.x, y: anchor.y };
      console.log('neckAnchor', {
        x: Number.parseFloat(formatFloat(anchor.x)),
        y: Number.parseFloat(formatFloat(anchor.y))
      });
    }

    function applyTorsoRig(liveTorso) {
      const torso = ensureTorso();
      if (!torso || !torso.node) return torsoRigState.lastNeckAnchor;
      const shoulders = liveTorso?.shoulders || {};
      const liveLeft = shoulders.left || null;
      const liveRight = shoulders.right || null;
      let matrix = null;
      if (torso.ready && liveLeft && liveRight) {
        matrix = similarityFrom2Points(
          torso.base.leftShoulder,
          torso.base.rightShoulder,
          liveLeft,
          liveRight
        );
      }
      if (!matrix) {
        matrix = torsoRigState.lastMatrix;
      }
      if (matrix) {
        applyMatrixToElement(torso.node, matrix);
        torsoRigState.lastMatrix = matrix;
      } else {
        applyMatrixToElement(torso.node, null);
        torsoRigState.lastMatrix = null;
      }
      let neckAnchor = null;
      if (matrix && torso.ready) {
        const baseMid = midpoint(torso.base.leftShoulder, torso.base.rightShoulder);
        if (baseMid) {
          const localAnchor = {
            x: baseMid.x + TORSO_NECK_OFFSET.x,
            y: baseMid.y + TORSO_NECK_OFFSET.y
          };
          neckAnchor = transformPoint(matrix, localAnchor);
        }
      }
      if (!neckAnchor && liveLeft && liveRight) {
        const liveMid = midpoint(liveLeft, liveRight);
        if (liveMid) {
          neckAnchor = {
            x: liveMid.x + TORSO_NECK_OFFSET.x,
            y: liveMid.y + TORSO_NECK_OFFSET.y
          };
        }
      }
      if (neckAnchor) {
        torsoRigState.lastNeckAnchor = { x: neckAnchor.x, y: neckAnchor.y };
        logNeckAnchor(torsoRigState.lastNeckAnchor);
        return torsoRigState.lastNeckAnchor;
      }
      return torsoRigState.lastNeckAnchor;
    }

    function invertMatrix(matrix) {
      if (!matrix) return null;
      const { a, b, c, d, e, f } = matrix;
      const det = a * d - b * c;
      if (Math.abs(det) < 1e-8) return null;
      const invDet = 1 / det;
      return {
        a: d * invDet,
        b: -b * invDet,
        c: -c * invDet,
        d: a * invDet,
        e: (c * f - d * e) * invDet,
        f: (b * e - a * f) * invDet
      };
    }

    function mapPoints(points, matrix) {
      if (!Array.isArray(points) || !matrix) return points;
      const mapped = [];
      for (const pt of points) {
        if (!pt) return null;
        const next = transformPoint(matrix, pt);
        if (!next) return null;
        mapped.push(next);
      }
      return mapped.length === points.length ? mapped : null;
    }

    function placeLine(line, start, end) {
      if (!line || !start || !end) return;
      line.setAttribute('x1', start.x);
      line.setAttribute('y1', start.y);
      line.setAttribute('x2', end.x);
      line.setAttribute('y2', end.y);
    }

    function placePolyline(polyline, points) {
      if (!polyline || !Array.isArray(points) || !points.length) return;
      const serialized = points.map((pt) => `${pt.x},${pt.y}`).join(' ');
      polyline.setAttribute('points', serialized);
    }

    function normalizeHandPoint(value) {
      if (!value) return null;
      const toNumber = (input) => {
        const num = Number.parseFloat(input);
        return Number.isFinite(num) ? num : null;
      };
      if (Array.isArray(value)) {
        if (value.length < 2) return null;
        const x = toNumber(value[0]);
        const y = toNumber(value[1]);
        return x == null || y == null ? null : { x, y };
      }
      if (typeof value === 'object') {
        if (value.x != null && value.y != null) {
          const x = toNumber(value.x);
          const y = toNumber(value.y);
          if (x != null && y != null) return { x, y };
        }
        if (value.X != null && value.Y != null) {
          const x = toNumber(value.X);
          const y = toNumber(value.Y);
          if (x != null && y != null) return { x, y };
        }
        if (Array.isArray(value.xy)) {
          const x = toNumber(value.xy[0]);
          const y = toNumber(value.xy[1]);
          if (x != null && y != null) return { x, y };
        }
        if (Array.isArray(value.point)) {
          const x = toNumber(value.point[0]);
          const y = toNumber(value.point[1]);
          if (x != null && y != null) return { x, y };
        }
        if (Array.isArray(value.coordinates)) {
          const x = toNumber(value.coordinates[0]);
          const y = toNumber(value.coordinates[1]);
          if (x != null && y != null) return { x, y };
        }
        if (Array.isArray(value.position)) {
          const x = toNumber(value.position[0]);
          const y = toNumber(value.position[1]);
          if (x != null && y != null) return { x, y };
        }
        if (value[0] != null && value[1] != null) {
          const x = toNumber(value[0]);
          const y = toNumber(value[1]);
          if (x != null && y != null) return { x, y };
        }
      }
      return null;
    }

    function propertyVariants(key) {
      if (typeof key !== 'string' || !key.length) return [key];
      const variants = new Set();
      variants.add(key);
      variants.add(key.toLowerCase());
      variants.add(key.toUpperCase());
      const camel = key.replace(/[_\s-]+(\w)/g, (_, ch) => ch.toUpperCase());
      if (camel) {
        variants.add(camel);
        variants.add(camel.charAt(0).toLowerCase() + camel.slice(1));
        variants.add(camel.charAt(0).toUpperCase() + camel.slice(1));
      }
      const snake = key
        .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
        .replace(/[-\s]+/g, '_')
        .toLowerCase();
      if (snake) {
        variants.add(snake);
      }
      return Array.from(variants);
    }

    function readHandProperty(source, key) {
      if (!source || !key) return null;
      for (const variant of propertyVariants(key)) {
        if (variant && source[variant] != null) {
          return source[variant];
        }
      }
      return null;
    }

    function resolveHandLandmarks(source) {
      if (!source) return null;
      const candidates = [
        Array.isArray(source) ? source : null,
        source?.landmarks,
        source?.landmark,
        source?.points,
        source?.coords,
        source?.points2D,
        source?.keypoints,
        source?.normalizedLandmarks,
        source?.joints,
        source?.positions,
        source?.data
      ];
      for (const candidate of candidates) {
        if (Array.isArray(candidate) && candidate.length) {
          return candidate;
        }
      }
      const numericKeys = Object.keys(source).filter((key) => /^\d+$/.test(key));
      if (numericKeys.length) {
        numericKeys.sort((a, b) => Number(a) - Number(b));
        const mapped = [];
        for (const key of numericKeys) {
          mapped[Number(key)] = source[key];
        }
        return mapped;
      }
      const landmarks = [];
      let hasAny = false;
      for (const [indexKey, aliases] of Object.entries(HAND_LANDMARK_ALIASES)) {
        const index = Number(indexKey);
        if (!Number.isFinite(index)) continue;
        let value = null;
        if (Array.isArray(aliases)) {
          for (const alias of aliases) {
            if (!alias) continue;
            if (source[alias] != null) {
              value = source[alias];
              break;
            }
            const lower = alias.toLowerCase();
            if (source[lower] != null) {
              value = source[lower];
              break;
            }
            const camel = alias
              .toLowerCase()
              .replace(/_(\w)/g, (_, ch) => ch.toUpperCase());
            if (source[camel] != null) {
              value = source[camel];
              break;
            }
          }
        }
        landmarks[index] = value ?? null;
        if (value != null) hasAny = true;
      }
      return hasAny ? landmarks : null;
    }

    function normalizeHandData(source) {
      const raw = resolveHandLandmarks(source);
      if (!raw) return null;
      const points = new Array(21).fill(null);
      for (let i = 0; i <= 20; i += 1) {
        points[i] = normalizeHandPoint(raw[i]);
      }
      if (!points[0]) return null;
      const palm = [];
      for (const index of HAND_PALM_CHAIN) {
        const pt = points[index];
        if (!pt) return null;
        palm.push({ x: pt.x, y: pt.y });
      }
      const fingers = {};
      for (const [finger, chain] of Object.entries(HAND_FINGER_CHAINS)) {
        const fingerPoints = [];
        let valid = true;
        for (const index of chain) {
          const pt = points[index];
          if (!pt) {
            valid = false;
            break;
          }
          fingerPoints.push({ x: pt.x, y: pt.y });
        }
        if (valid && fingerPoints.length >= 2) {
          fingers[finger] = fingerPoints;
        }
      }
      return { palm, fingers };
    }

    function detectHandSide(hand) {
      if (!hand) return null;
      const inspect = (value) => {
        if (!value) return null;
        if (typeof value === 'string') {
          const normalized = value.toLowerCase();
          if (normalized.includes('left')) return 'left';
          if (normalized.includes('right')) return 'right';
          return null;
        }
        if (Array.isArray(value)) {
          for (const entry of value) {
            const result = inspect(entry);
            if (result) return result;
          }
          return null;
        }
        if (typeof value === 'object') {
          const candidates = [
            value.label,
            value.category,
            value.categoryName,
            value.type,
            value.side,
            value.name
          ];
          for (const candidate of candidates) {
            const result = inspect(candidate);
            if (result) return result;
          }
        }
        return null;
      };
      const candidates = [
        hand.side,
        hand.label,
        hand.type,
        hand.which,
        hand.name,
        hand.category,
        hand.handedness,
        hand.handedness?.label,
        hand.handedness?.categoryName,
        hand.handedness?.type
      ];
      for (const candidate of candidates) {
        const result = inspect(candidate);
        if (result) return result;
      }
      return null;
    }

    function extractHandFromKeypoints(keypoints, side) {
      if (!keypoints || !HAND_KEYPOINT_NAME_MAP[side]) return null;
      const map = HAND_KEYPOINT_NAME_MAP[side];
      const raw = [];
      let count = 0;
      for (const [indexKey, names] of Object.entries(map)) {
        const index = Number(indexKey);
        if (!Number.isFinite(index)) continue;
        let value = null;
        for (const name of names) {
          if (!name) continue;
          if (keypoints[name]) {
            value = keypoints[name];
            break;
          }
        }
        raw[index] = value ?? null;
        if (value != null) count += 1;
      }
      if (!count) return null;
      return normalizeHandData(raw);
    }

    function extractHandsFromFrame(frame, keypoints) {
      const result = { left: null, right: null };
      const visitedContainers = new Set();
      const visitedCollections = new Set();
      const assign = (side, source) => {
        if (!source || (side !== 'left' && side !== 'right') || result[side]) return;
        const normalized = normalizeHandData(source);
        if (normalized) {
          result[side] = normalized;
        }
      };

      const inspectCollection = (collection) => {
        if (
          !collection ||
          visitedCollections.has(collection) ||
          (result.left && result.right)
        )
          return;
        visitedCollections.add(collection);
        if (Array.isArray(collection)) {
          for (const entry of collection) {
            if (result.left && result.right) break;
            const side = detectHandSide(entry);
            if (side) {
              assign(side, entry);
            }
          }
        } else if (typeof collection === 'object') {
          inspectContainer(collection);
        }
      };

      const inspectContainer = (container) => {
        if (!container || visitedContainers.has(container) || (result.left && result.right)) return;
        visitedContainers.add(container);
        const directLeft = HAND_SIDE_KEYS.left;
        const directRight = HAND_SIDE_KEYS.right;
        for (const key of directLeft) {
          if (result.left) break;
          assign('left', readHandProperty(container, key));
        }
        for (const key of directRight) {
          if (result.right) break;
          assign('right', readHandProperty(container, key));
        }
        const collections = [
          container.hands,
          container.hand,
          container.multiHandLandmarks,
          container.handLandmarks,
          container.multiHands
        ];
        for (const candidate of collections) {
          if (result.left && result.right) break;
          inspectCollection(candidate);
        }
      };

      inspectContainer(frame);
      inspectContainer(frame?.live);
      inspectCollection(frame?.live?.hands);
      inspectCollection(frame?.live?.hand);
      inspectCollection(frame?.live?.multiHandLandmarks);
      inspectCollection(frame?.live?.handLandmarks);
      inspectCollection(frame?.live?.multiHands);

      if (!result.left) {
        const leftFallback = extractHandFromKeypoints(keypoints, 'left');
        if (leftFallback) result.left = leftFallback;
      }
      if (!result.right) {
        const rightFallback = extractHandFromKeypoints(keypoints, 'right');
        if (rightFallback) result.right = rightFallback;
      }
      return result;
    }

    function fingerCapsuleRadius(finger) {
      const width = FINGER_CAPSULE_WIDTHS[finger] ?? 20;
      const radius = width / 2;
      return radius > 0 ? radius : 6;
    }

    function buildCapsulePath(start, end, radius) {
      if (!start || !end || !Number.isFinite(radius) || radius <= 0) return '';
      const dx = end.x - start.x;
      const dy = end.y - start.y;
      const length = Math.hypot(dx, dy);
      if (!Number.isFinite(length) || length < 1e-3) return '';
      const ux = dx / length;
      const uy = dy / length;
      const px = -uy;
      const py = ux;
      const offsetX = px * radius;
      const offsetY = py * radius;
      const a1 = { x: start.x + offsetX, y: start.y + offsetY };
      const a2 = { x: start.x - offsetX, y: start.y - offsetY };
      const b1 = { x: end.x + offsetX, y: end.y + offsetY };
      const b2 = { x: end.x - offsetX, y: end.y - offsetY };
      const r = formatFloat(radius);
      return [
        'M',
        formatFloat(a1.x),
        formatFloat(a1.y),
        'L',
        formatFloat(b1.x),
        formatFloat(b1.y),
        'A',
        r,
        r,
        '0 0 1',
        formatFloat(b2.x),
        formatFloat(b2.y),
        'L',
        formatFloat(a2.x),
        formatFloat(a2.y),
        'A',
        r,
        r,
        '0 0 1',
        formatFloat(a1.x),
        formatFloat(a1.y),
        'Z'
      ].join(' ');
    }

    function ensureDebugHands(svg = svgEl) {
      const context = svg || svgEl;
      if (!context) return handDebug;
      let root = context.getElementById ? context.getElementById('debugHands') : null;
      if (!root) {
        root = document.createElementNS(NS, 'g');
        root.id = 'debugHands';
        root.setAttribute('fill', 'none');
        root.style.pointerEvents = 'none';
        root.setAttribute('data-debug-line', 'true');
      }
      if (root.parentNode !== context) {
        context.appendChild(root);
      }
      handDebug.root = root;
      const ensureSide = (side) => {
        const info = handDebug[side];
        if (!info) return;
        let group = context.getElementById ? context.getElementById(`debugHand-${side}`) : null;
        if (!group) {
          group = document.createElementNS(NS, 'g');
          group.id = `debugHand-${side}`;
        }
        if (group.parentNode !== root) {
          root.appendChild(group);
        }
        info.group = group;
        if (!group.hasAttribute('data-debug-initialized')) {
          group.style.display = 'none';
          group.setAttribute('data-debug-initialized', 'true');
        }

        let palm = context.getElementById ? context.getElementById(`${side}-palm`) : null;
        if (!palm) {
          palm = document.createElementNS(NS, 'polyline');
          palm.id = `${side}-palm`;
        }
        palm.setAttribute('fill', 'none');
        palm.setAttribute('stroke', 'rgba(74, 139, 255, 0.42)');
        palm.setAttribute('stroke-width', '3.2');
        palm.setAttribute('stroke-linecap', 'round');
        palm.setAttribute('stroke-linejoin', 'round');
        palm.style.pointerEvents = 'none';
        palm.style.mixBlendMode = 'screen';
        if (palm.parentNode !== group) {
          group.appendChild(palm);
        }
        info.palm = palm;
        palm.style.display = 'none';

        let bonesGroup = context.getElementById ? context.getElementById(`${side}-bones`) : null;
        if (!bonesGroup) {
          bonesGroup = document.createElementNS(NS, 'g');
          bonesGroup.id = `${side}-bones`;
        }
        bonesGroup.style.pointerEvents = 'none';
        bonesGroup.setAttribute('fill', 'none');
        bonesGroup.setAttribute('stroke-linecap', 'round');
        bonesGroup.setAttribute('stroke-linejoin', 'round');
        if (bonesGroup.parentNode !== group) {
          group.appendChild(bonesGroup);
        }
        info.bonesGroup = bonesGroup;

        let capsulesGroup = context.getElementById ? context.getElementById(`${side}-capsules`) : null;
        if (!capsulesGroup) {
          capsulesGroup = document.createElementNS(NS, 'g');
          capsulesGroup.id = `${side}-capsules`;
        }
        capsulesGroup.style.pointerEvents = 'none';
        capsulesGroup.setAttribute('stroke-linecap', 'round');
        capsulesGroup.setAttribute('stroke-linejoin', 'round');
        if (capsulesGroup.parentNode !== group) {
          group.appendChild(capsulesGroup);
        }
        info.capsulesGroup = capsulesGroup;

        if (!(info.bones instanceof Map)) {
          info.bones = new Map();
        }
        if (!(info.capsules instanceof Map)) {
          info.capsules = new Map();
        }
      };

      ensureSide('left');
      ensureSide('right');

      if (debugToggles && typeof debugToggles.fingers !== 'undefined') {
        root.style.display = debugToggles.fingers ? '' : 'none';
      }

      return handDebug;
    }

    function getOrCreateHandLine(info, key) {
      if (!info || !info.bonesGroup) return null;
      let line = info.bones.get(key);
      if (!line) {
        line = document.createElementNS(NS, 'line');
        line.setAttribute('stroke', 'rgba(74, 139, 255, 0.58)');
        line.setAttribute('stroke-width', '2.6');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('stroke-linejoin', 'round');
        line.style.pointerEvents = 'none';
        info.bonesGroup.appendChild(line);
        info.bones.set(key, line);
      } else if (line.parentNode !== info.bonesGroup) {
        info.bonesGroup.appendChild(line);
      }
      return line;
    }

    function getOrCreateHandCapsule(info, key, finger) {
      if (!info || !info.capsulesGroup) return null;
      let capsule = info.capsules.get(key);
      if (!capsule) {
        capsule = document.createElementNS(NS, 'path');
        capsule.setAttribute('fill', 'rgba(255, 214, 197, 0.32)');
        capsule.setAttribute('stroke', 'rgba(214, 160, 130, 0.45)');
        capsule.setAttribute('stroke-width', '1.6');
        capsule.setAttribute('stroke-linecap', 'round');
        capsule.setAttribute('stroke-linejoin', 'round');
        capsule.style.pointerEvents = 'none';
        info.capsulesGroup.appendChild(capsule);
        info.capsules.set(key, capsule);
      } else if (capsule.parentNode !== info.capsulesGroup) {
        info.capsulesGroup.appendChild(capsule);
      }
      capsule.dataset.finger = finger;
      return capsule;
    }

    function hideHandSide(info) {
      if (!info) return;
      if (info.group) info.group.style.display = 'none';
      if (info.palm) info.palm.style.display = 'none';
      if (info.bones instanceof Map) {
        for (const line of info.bones.values()) {
          if (line) line.style.display = 'none';
        }
      }
      if (info.capsules instanceof Map) {
        for (const capsule of info.capsules.values()) {
          if (capsule) capsule.style.display = 'none';
        }
      }
    }

    function updateHandSideDebug(side, handData, rig) {
      const info = handDebug[side];
      if (!info || !info.group || !handData || !rig) {
        hideHandSide(info);
        return false;
      }
      const palmPoints = mapPoints(handData.palm, rig);
      if (!Array.isArray(palmPoints) || !palmPoints.length) {
        hideHandSide(info);
        return false;
      }
      ensureDebugHands();
      placePolyline(info.palm, palmPoints);
      info.palm.style.display = '';
      const usedBones = new Set();
      const usedCapsules = new Set();
      const fingers = handData.fingers || {};
      for (const [finger, chain] of Object.entries(fingers)) {
        const mappedFinger = mapPoints(chain, rig);
        if (!Array.isArray(mappedFinger) || mappedFinger.length < 2) continue;
        for (let i = 0; i < mappedFinger.length - 1; i += 1) {
          const start = mappedFinger[i];
          const end = mappedFinger[i + 1];
          const key = `${finger}-${i}`;
          const line = getOrCreateHandLine(info, key);
          if (line) {
            placeLine(line, start, end);
            line.style.display = '';
            usedBones.add(key);
          }
          const capsule = getOrCreateHandCapsule(info, key, finger);
          if (capsule) {
            const radius = fingerCapsuleRadius(finger);
            const path = buildCapsulePath(start, end, radius);
            if (path) {
              capsule.setAttribute('d', path);
              capsule.style.display = '';
              usedCapsules.add(key);
            } else {
              capsule.style.display = 'none';
            }
          }
        }
      }
      if (info.bones instanceof Map) {
        for (const [key, line] of info.bones.entries()) {
          if (!usedBones.has(key) && line) {
            line.style.display = 'none';
          }
        }
      }
      if (info.capsules instanceof Map) {
        for (const [key, capsule] of info.capsules.entries()) {
          if (!usedCapsules.has(key) && capsule) {
            capsule.style.display = 'none';
          }
        }
      }
      info.group.style.display = '';
      return true;
    }

    function updateHandsDebug(hands, rig) {
      ensureDebugHands();
      if (!handDebug.root) return;
      const left = hands?.left || null;
      const right = hands?.right || null;
      const leftUpdated = updateHandSideDebug('left', left, rig);
      const rightUpdated = updateHandSideDebug('right', right, rig);
      if (!leftUpdated && !rightUpdated) {
        hideHandSide(handDebug.left);
        hideHandSide(handDebug.right);
      }
      if (debugToggles && typeof debugToggles.fingers !== 'undefined') {
        handDebug.root.style.display = debugToggles.fingers ? '' : 'none';
      }
    }

    function computeSimilarityTransform(fromPoints, toPoints) {
      if (!Array.isArray(fromPoints) || !Array.isArray(toPoints)) return null;
      const count = Math.min(fromPoints.length, toPoints.length);
      if (!count) return null;
      if (count === 1) {
        const from = fromPoints[0];
        const to = toPoints[0];
        if (!from || !to) return null;
        return {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: to.x - from.x,
          f: to.y - from.y
        };
      }

      let sumFx = 0;
      let sumFy = 0;
      let sumTx = 0;
      let sumTy = 0;
      for (let i = 0; i < count; i += 1) {
        const from = fromPoints[i];
        const to = toPoints[i];
        if (!from || !to) return null;
        sumFx += from.x;
        sumFy += from.y;
        sumTx += to.x;
        sumTy += to.y;
      }

      const meanFrom = { x: sumFx / count, y: sumFy / count };
      const meanTo = { x: sumTx / count, y: sumTy / count };

      let denom = 0;
      let dot = 0;
      let cross = 0;
      for (let i = 0; i < count; i += 1) {
        const from = fromPoints[i];
        const to = toPoints[i];
        const fx = from.x - meanFrom.x;
        const fy = from.y - meanFrom.y;
        const tx = to.x - meanTo.x;
        const ty = to.y - meanTo.y;
        denom += fx * fx + fy * fy;
        dot += fx * tx + fy * ty;
        cross += fx * ty - fy * tx;
      }

      if (denom < 1e-6) {
        return {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: meanTo.x - meanFrom.x,
          f: meanTo.y - meanFrom.y
        };
      }

      const norm = Math.hypot(dot, cross);
      if (norm < 1e-6) {
        return {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: meanTo.x - meanFrom.x,
          f: meanTo.y - meanFrom.y
        };
      }

      const scale = norm / denom;
      const cos = dot / norm;
      const sin = cross / norm;
      const a = scale * cos;
      const b = scale * sin;
      const c = -scale * sin;
      const d = scale * cos;
      const e = meanTo.x - (a * meanFrom.x + c * meanFrom.y);
      const f = meanTo.y - (b * meanFrom.x + d * meanFrom.y);

      return { a, b, c, d, e, f };
    }

    function adjustMatrixTranslation(matrix, pairs) {
      if (!matrix || !Array.isArray(pairs) || !pairs.length) return matrix;
      let offsetX = 0;
      let offsetY = 0;
      let count = 0;
      for (const pair of pairs) {
        if (!pair || !pair.base || !pair.target) continue;
        const current = transformPoint(matrix, pair.base);
        if (!current) continue;
        offsetX += pair.target.x - current.x;
        offsetY += pair.target.y - current.y;
        count += 1;
      }
      if (!count) return matrix;
      return {
        ...matrix,
        e: matrix.e + offsetX / count,
        f: matrix.f + offsetY / count
      };
    }

    function validateSegment(label, basePoints, targetPoints, matrix) {
      if (!matrix || !Array.isArray(basePoints) || !Array.isArray(targetPoints)) return;
      const count = Math.min(basePoints.length, targetPoints.length);
      if (!count) return;
      let maxError = 0;
      for (let i = 0; i < count; i += 1) {
        const source = basePoints[i];
        const target = targetPoints[i];
        if (!source || !target) continue;
        const transformed = transformPoint(matrix, source);
        if (!transformed) continue;
        const error = dist(transformed, target);
        if (error > maxError) {
          maxError = error;
        }
      }
      if (maxError > VALIDATION_TOLERANCE && !validationNotified.has(label)) {
        console.warn(`Alinhamento do segmento ${label} excedeu a tolerância (${formatFloat(maxError)}px).`);
        validationNotified.add(label);
      }
    }

    function applyHeadTransform(matrix) {
      if (!headTargets.length) return;
      if (matrix) {
        const { a, b, c, d, e, f } = matrix;
        for (const target of headTargets) {
          if (target) target.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
        }
        lastHeadMatrix = { a, b, c, d, e, f };
        return;
      }
      if (lastHeadMatrix) {
        const { a, b, c, d, e, f } = lastHeadMatrix;
        for (const target of headTargets) {
          if (target) target.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
        }
        return;
      }
      for (const target of headTargets) {
        if (target) target.removeAttribute('transform');
      }
    }

    function applyBodyTransform(matrix) {
      if (!bodyTargets.length) return;
      if (matrix) {
        const { a, b, c, d, e, f } = matrix;
        for (const target of bodyTargets) {
          if (target) target.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
        }
        lastBodyMatrix = { a, b, c, d, e, f };
        return;
      }
      if (lastBodyMatrix) {
        const { a, b, c, d, e, f } = lastBodyMatrix;
        for (const target of bodyTargets) {
          if (target) target.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
        }
        return;
      }
      for (const target of bodyTargets) {
        if (target) target.removeAttribute('transform');
      }
    }

    function updateVisibility() {
      const showLeft = debugToggles.leftArm;
      const showRight = debugToggles.rightArm;
      const showBody = debugToggles.body;
      const showFace = debugToggles.face;
      const showHands = debugToggles.fingers;
      const showFaceOverlay = debugToggles.faceOverlay;

      if (armPaths.left) armPaths.left.style.display = showLeft ? 'block' : 'none';
      if (armPaths.right) armPaths.right.style.display = showRight ? 'block' : 'none';
      if (handDebug.root) handDebug.root.style.display = showHands ? '' : 'none';

      const toggle = (elements, show) => {
        for (const el of elements) {
          if (!el) continue;
          el.style.display = show ? 'block' : 'none';
        }
      };

      toggle([segments.left.upper, segments.left.lower], showLeft);
      toggle([segments.right.upper, segments.right.lower], showRight);
      toggle([
        segments.body.top,
        segments.body.bottom,
        segments.body.left,
        segments.body.right,
        segments.body.center
      ], showBody);

      toggle(segments.face.map((guide) => guide.debug), showFace);

      if (faceOverlayLayer) {
        faceOverlayLayer.style.display = showFaceOverlay ? '' : 'none';
      }

      const updateArmElements = (side) => {
        const arm = puppetArms[side];
        if (!arm) return;
        const visible = arm.ready;
        if (arm.upper) arm.upper.style.display = visible ? '' : 'none';
        if (arm.lower) arm.lower.style.display = visible ? '' : 'none';
      };

      updateArmElements('left');
      updateArmElements('right');
    }

    let frames = [];
    let frameIndex = 0;
    let svgEl = null;
    let playbackSpeed = DEFAULT_PLAYBACK_SPEED;
    let frameAccumulator = 0;
    let lastTickTime = null;
    const segments = {
      left: { upper: null, lower: null },
      right: { upper: null, lower: null },
      body: { top: null, bottom: null, left: null, right: null, center: null },
      face: []
    };
    const armPaths = { left: null, right: null };
    let running = false;
    const puppetArms = {
      left: { upper: null, lower: null, ready: false, warningShown: false, base: { A: null, B: null, C: null } },
      right: { upper: null, lower: null, ready: false, warningShown: false, base: { A: null, B: null, C: null } }
    };
    const handDebug = {
      root: null,
      left: {
        group: null,
        palm: null,
        bonesGroup: null,
        capsulesGroup: null,
        bones: new Map(),
        capsules: new Map()
      },
      right: {
        group: null,
        palm: null,
        bonesGroup: null,
        capsulesGroup: null,
        bones: new Map(),
        capsules: new Map()
      }
    };
    const handSmoothState = {
      left: null,
      right: null
    };

    function cloneHandData(hand) {
      if (!hand) return null;
      const palm = Array.isArray(hand.palm)
        ? hand.palm.every(Boolean)
          ? hand.palm.map((pt) => ({ x: pt.x, y: pt.y }))
          : []
        : [];
      if (!palm.length) return null;
      const fingers = {};
      if (hand.fingers && typeof hand.fingers === 'object') {
        for (const [finger, chain] of Object.entries(hand.fingers)) {
          if (!Array.isArray(chain) || chain.length < 2) continue;
          const valid = chain.every(Boolean);
          if (!valid) continue;
          fingers[finger] = chain.map((pt) => ({ x: pt.x, y: pt.y }));
        }
      }
      return { palm, fingers };
    }

    function smoothHandSide(side, nextHand) {
      const previous = handSmoothState[side];
      if (!nextHand) {
        return previous ? cloneHandData(previous) : null;
      }
      const rawPalm = Array.isArray(nextHand.palm) ? nextHand.palm : [];
      if (!rawPalm.length) {
        return previous ? cloneHandData(previous) : null;
      }
      const prevPalm = previous?.palm || [];
      const smoothedPalm = [];
      for (let i = 0; i < rawPalm.length; i += 1) {
        const current = rawPalm[i];
        const fallback = prevPalm[i] || null;
        if (!current && !fallback) {
          return previous ? cloneHandData(previous) : null;
        }
        const source = current || fallback;
        const blended = current && fallback
          ? EMA(fallback, current, HAND_SMOOTH_ALPHA)
          : source;
        smoothedPalm.push({ x: blended.x, y: blended.y });
      }

      const prevFingers = previous?.fingers || {};
      const smoothedFingers = {};
      if (nextHand.fingers && typeof nextHand.fingers === 'object') {
        for (const [finger, chain] of Object.entries(nextHand.fingers)) {
          const prevChain = Array.isArray(prevFingers[finger]) ? prevFingers[finger] : [];
          if (!Array.isArray(chain) || chain.length < 2) {
            if (prevChain.length >= 2) {
              smoothedFingers[finger] = prevChain.map((pt) => ({ x: pt.x, y: pt.y }));
            }
            continue;
          }
          const smoothedChain = [];
          let valid = true;
          for (let i = 0; i < chain.length; i += 1) {
            const current = chain[i];
            const fallback = prevChain[i] || null;
            if (!current && !fallback) {
              valid = false;
              break;
            }
            const source = current || fallback;
            const blended = current && fallback
              ? EMA(fallback, current, HAND_SMOOTH_ALPHA)
              : source;
            smoothedChain.push({ x: blended.x, y: blended.y });
          }
          if (valid && smoothedChain.length >= 2) {
            smoothedFingers[finger] = smoothedChain;
          } else if (prevChain.length >= 2) {
            smoothedFingers[finger] = prevChain.map((pt) => ({ x: pt.x, y: pt.y }));
          }
        }
      }

      for (const [finger, prevChain] of Object.entries(prevFingers)) {
        if (smoothedFingers[finger]) continue;
        if (Array.isArray(prevChain) && prevChain.length >= 2) {
          smoothedFingers[finger] = prevChain.map((pt) => ({ x: pt.x, y: pt.y }));
        }
      }

      const result = { palm: smoothedPalm, fingers: smoothedFingers };
      const snapshot = cloneHandData(result);
      handSmoothState[side] = snapshot;
      return snapshot ? cloneHandData(snapshot) : null;
    }

    function smoothHands(hands) {
      const left = smoothHandSide('left', hands?.left || null);
      const right = smoothHandSide('right', hands?.right || null);
      return { left, right };
    }

    function resetHandSmoothing() {
      handSmoothState.left = null;
      handSmoothState.right = null;
    }

    function normalizePuppetStructure() {
      if (!svgEl) return;
      const illustration = svgEl.getElementById('illustration');
      if (!illustration) return;

      const existingBody = svgEl.getElementById('puppet_body');
      const existingHead = svgEl.getElementById('puppet_head_base');
      const existingHeadRig = svgEl.getElementById('puppet_head_rig');
      const bodyGroup = existingBody || document.createElementNS(NS, 'g');
      const headGroup = existingHead || document.createElementNS(NS, 'g');
      const headRig = existingHeadRig || document.createElementNS(NS, 'g');

      if (!existingBody) {
        bodyGroup.id = 'puppet_body';
      }
      if (!existingHead) {
        headGroup.id = 'puppet_head_base';
      }
      if (!existingHeadRig) {
        headRig.id = 'puppet_head_rig';
      }

      const headNodes = [];
      const bodyNodes = [];
      const HEAD_THRESHOLD = 330;
      const skipIds = new Set([FACE_OVERLAY_ID, LEGACY_FACE_OVERLAY_ID]);

      const children = Array.from(illustration.children);
      children.forEach((node) => {
        if (node === bodyGroup || node === headGroup || node === headRig) return;
        if (node.nodeType !== 1) return;
        if (skipIds.has(node.id)) return;
        if (node.id === 'face_templates') return;
        const bbox = typeof node.getBBox === 'function' ? node.getBBox() : null;
        const centerY = bbox ? bbox.y + bbox.height / 2 : Number.POSITIVE_INFINITY;
        if (centerY < HEAD_THRESHOLD) headNodes.push(node);
        else bodyNodes.push(node);
      });

      if (!existingBody || bodyGroup.parentNode !== illustration) {
        illustration.insertBefore(bodyGroup, illustration.firstChild);
      }

      if (!headRig.parentNode || headRig.parentNode !== illustration) {
        illustration.appendChild(headRig);
      }

      if (bodyGroup.parentNode === illustration) {
        illustration.insertBefore(headRig, bodyGroup.nextSibling);
      }

      if (headGroup.parentNode !== headRig) {
        headRig.appendChild(headGroup);
      }

      headNodes.forEach((node) => {
        if (node.parentNode !== headGroup) headGroup.appendChild(node);
      });
      bodyNodes.forEach((node) => {
        if (node.parentNode !== bodyGroup) bodyGroup.appendChild(node);
      });

      let headFront = svgEl.getElementById('puppet_head_front');
      if (!headFront) {
        headFront = document.createElementNS(NS, 'g');
        headFront.id = 'puppet_head_front';
      }
      if (headFront.parentNode !== headRig) {
        headRig.appendChild(headFront);
      } else {
        headRig.appendChild(headFront);
      }

      Array.from(headGroup.children).forEach((child) => {
        const tag = child.tagName ? child.tagName.toLowerCase() : '';
        if (tag === 'g' && !child.id) {
          child.style.display = 'none';
        }
      });
    }
    const lastArmRigs = { left: null, right: null };
    const lastArmMatrices = {
      left: { upper: null, lower: null },
      right: { upper: null, lower: null }
    };

    function configureArmElement(el) {
      if (!el) return;
      el.style.transformBox = 'fill-box';
      el.style.transformOrigin = '50% 50%';
      el.removeAttribute('transform');
      el.style.transform = '';
    }

    function ensurePuppetArm(side, svg = svgEl) {
      const context = svg || svgEl;
      const arm = puppetArms[side];
      if (!context || !arm) return null;
      const upper = context.getElementById ? context.getElementById(`${side}UpperArm`) : null;
      const lower = context.getElementById ? context.getElementById(`${side}LowerArm`) : null;
      arm.upper = upper || null;
      arm.lower = lower || null;
      arm.base.A = parseDataPoint(upper?.dataset?.shoulder) || null;
      arm.base.B = parseDataPoint(upper?.dataset?.elbow) || null;
      arm.base.C = parseDataPoint(lower?.dataset?.wrist) || null;
      arm.ready = Boolean(arm.upper && arm.lower && arm.base.A && arm.base.B && arm.base.C);
      if (arm.upper) {
        configureArmElement(arm.upper);
        arm.upper.classList.add('joint');
      }
      if (arm.lower) {
        configureArmElement(arm.lower);
        arm.lower.classList.add('joint');
      }
      if (arm.ready) {
        lastArmMatrices[side].upper = null;
        lastArmMatrices[side].lower = null;
        return arm;
      }
      return null;
    }

    function applyArmRig(side, rig) {
      const arm = puppetArms[side];
      if (!arm || !arm.ready) {
        return;
      }
      const live = rig || lastArmRigs[side] || null;
      const { A, B, C } = live || {};
      const applySegment = (element, baseStart, baseEnd, targetStart, targetEnd, key, label) => {
        if (!element || !baseStart || !baseEnd) {
          return null;
        }
        const matrix = targetStart && targetEnd
          ? similarityFrom2Points(baseStart, baseEnd, targetStart, targetEnd)
          : null;
        const next = matrix || lastArmMatrices[side][key] || null;
        if (!next) {
          applyMatrixToElement(element, null);
          return null;
        }
        applyMatrixToElement(element, next);
        if (matrix) {
          lastArmMatrices[side][key] = matrix;
          if (targetStart && targetEnd) {
            validateSegment(label, [baseStart, baseEnd], [targetStart, targetEnd], matrix);
          }
        }
        return next;
      };

      applySegment(arm.upper, arm.base.A, arm.base.B, A, B, 'upper', `arm-${side}-upper`);
      applySegment(arm.lower, arm.base.B, arm.base.C, B, C, 'lower', `arm-${side}-lower`);
    }

    function seg(id, stroke = '#4a8bff', width = 10) {
      const line = document.createElementNS(NS, 'line');
      line.id = id;
      line.setAttribute('stroke', stroke);
      line.setAttribute('stroke-width', width);
      line.setAttribute('stroke-linecap', 'round');
      line.classList.add('joint');
      line.setAttribute('data-debug-line', 'true');
      svgEl.appendChild(line);
      return line;
    }

    function faceGuide(id, stroke = '#4a8bff', width = 6) {
      const poly = document.createElementNS(NS, 'polyline');
      poly.id = id;
      poly.setAttribute('fill', 'none');
      poly.setAttribute('stroke', stroke);
      poly.setAttribute('stroke-width', width);
      poly.setAttribute('stroke-linecap', 'round');
      poly.setAttribute('stroke-linejoin', 'round');
      poly.classList.add('joint');
      poly.setAttribute('data-debug-line', 'true');
      svgEl.appendChild(poly);
      return poly;
    }

    function recomputePuppetMeasurements() {
      PUPPET_SHOULDERS_MID.x = (PUPPET_LEFT_SH.x + PUPPET_RIGHT_SH.x) / 2;
      PUPPET_SHOULDERS_MID.y = (PUPPET_LEFT_SH.y + PUPPET_RIGHT_SH.y) / 2;
      PUPPET_UPPER_ARM_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_EL);
      PUPPET_LOWER_ARM_LEN = dist(PUPPET_LEFT_EL, PUPPET_LEFT_WR);
      PUPPET_RIGHT_UPPER_ARM_LEN = dist(PUPPET_RIGHT_SH, PUPPET_RIGHT_EL);
      PUPPET_RIGHT_LOWER_ARM_LEN = dist(PUPPET_RIGHT_EL, PUPPET_RIGHT_WR);
      PUPPET_HIP_SPAN = dist(PUPPET_LEFT_HIP, PUPPET_RIGHT_HIP);
      PUPPET_TORSO_CENTER_LEN = dist(
        PUPPET_SHOULDERS_MID,
        mid(PUPPET_LEFT_HIP, PUPPET_RIGHT_HIP)
      );
      PUPPET_LEFT_TORSO_LEN = dist(PUPPET_LEFT_SH, PUPPET_LEFT_HIP);
      PUPPET_RIGHT_TORSO_LEN = dist(PUPPET_RIGHT_SH, PUPPET_RIGHT_HIP);

      const bodySources = [
        PUPPET_RIGHT_SH,
        PUPPET_LEFT_SH,
        PUPPET_RIGHT_HIP,
        PUPPET_LEFT_HIP
      ];
      for (let i = 0; i < PUPPET_BODY_BASE.length && i < bodySources.length; i += 1) {
        const source = bodySources[i];
        const target = PUPPET_BODY_BASE[i];
        if (!source || !target) continue;
        target.x = source.x;
        target.y = source.y;
      }

      const updateArmBase = (side, start, mid, end) => {
        if (!PUPPET_ARM_BASES?.[side]) return;
        const upper = PUPPET_ARM_BASES[side].upper;
        const lower = PUPPET_ARM_BASES[side].lower;
        if (upper) {
          if (upper[0]) { upper[0].x = start.x; upper[0].y = start.y; }
          if (upper[1]) { upper[1].x = mid.x; upper[1].y = mid.y; }
        }
        if (lower) {
          if (lower[0]) { lower[0].x = mid.x; lower[0].y = mid.y; }
          if (lower[1]) { lower[1].x = end.x; lower[1].y = end.y; }
        }
      };

      updateArmBase('left', PUPPET_LEFT_SH, PUPPET_LEFT_EL, PUPPET_LEFT_WR);
      updateArmBase('right', PUPPET_RIGHT_SH, PUPPET_RIGHT_EL, PUPPET_RIGHT_WR);
    }

    function updatePuppetMeasurementsFromSkeleton() {
      const overrides = {
        leftShoulder: readPoint('leftShoulder'),
        rightShoulder: readPoint('rightShoulder'),
        leftElbow: readPoint('leftElbow'),
        rightElbow: readPoint('rightElbow'),
        leftWrist: readPoint('leftWrist'),
        rightWrist: readPoint('rightWrist'),
        leftHip: readPoint('leftHip'),
        rightHip: readPoint('rightHip')
      };

      if (overrides.leftShoulder) Object.assign(PUPPET_LEFT_SH, overrides.leftShoulder);
      if (overrides.rightShoulder) Object.assign(PUPPET_RIGHT_SH, overrides.rightShoulder);
      if (overrides.leftElbow) Object.assign(PUPPET_LEFT_EL, overrides.leftElbow);
      if (overrides.rightElbow) Object.assign(PUPPET_RIGHT_EL, overrides.rightElbow);
      if (overrides.leftWrist) Object.assign(PUPPET_LEFT_WR, overrides.leftWrist);
      if (overrides.rightWrist) Object.assign(PUPPET_RIGHT_WR, overrides.rightWrist);
      if (overrides.leftHip) Object.assign(PUPPET_LEFT_HIP, overrides.leftHip);
      if (overrides.rightHip) Object.assign(PUPPET_RIGHT_HIP, overrides.rightHip);

      recomputePuppetMeasurements();
    }

    function computeFaceAnchorAdjustments() {
      if (!faceTemplatesRoot) return;
      const deltas = [];
      for (const pair of FACE_TEMPLATE_POINT_PAIRS) {
        const base = readPoint(pair.skeleton);
        const templatePt = readTemplatePoint(pair.template);
        if (!base || !templatePt) continue;
        deltas.push({
          x: templatePt.x - base.x,
          y: templatePt.y - base.y
        });
      }
      if (!deltas.length) return;
      let sumX = 0;
      let sumY = 0;
      for (const delta of deltas) {
        sumX += delta.x;
        sumY += delta.y;
      }
      FACE_ANCHOR_ADJUST.x = sumX / deltas.length;
      FACE_ANCHOR_ADJUST.y = sumY / deltas.length;
    }

    const faceFeatureRegistry = new Map();

    function ensureFaceOverlayGroup(id) {
      if (!faceOverlayLayer || !id) return null;
      if (faceOverlayGroups.has(id)) {
        const existing = faceOverlayGroups.get(id);
        if (existing && existing.parentNode !== faceOverlayLayer) {
          faceOverlayLayer.appendChild(existing);
        }
        return existing;
      }
      let group = faceOverlayLayer.querySelector(`#${escapeSelector(id)}`);
      if (!group) {
        group = document.createElementNS(NS, 'g');
        group.id = id;
      }
      group.style.pointerEvents = 'none';
      if (!group.parentNode) {
        faceOverlayLayer.appendChild(group);
      }
      faceOverlayGroups.set(id, group);
      return group;
    }

    function ensureFaceOverlayGroups() {
      ensureFaceOverlayGroup(FACE_OVERLAY_SUBGROUP_IDS.skin);
      ensureFaceOverlayGroup(FACE_OVERLAY_SUBGROUP_IDS.mouth);
      ensureFaceOverlayGroup(FACE_OVERLAY_SUBGROUP_IDS.nose);
      ensureFaceOverlayGroup(FACE_OVERLAY_SUBGROUP_IDS.eyes);
      ensureFaceOverlayGroup(FACE_OVERLAY_SUBGROUP_IDS.brows);
    }

    function positionFaceOverlayLayer() {
      if (!svgEl || !faceOverlayLayer) return;
      ensureFaceOverlayGroups();
      const parent = svgEl;
      let reference = null;
      const debugNode = parent.querySelector('[data-debug-line]');
      if (debugNode && debugNode.parentNode === parent) {
        reference = debugNode;
      } else {
        const headNode = svgEl.getElementById('head');
        if (headNode && headNode.parentNode === parent) {
          reference = headNode.nextSibling;
        } else {
          const illustration = svgEl.getElementById('illustration');
          if (illustration && illustration.parentNode === parent) {
            reference = illustration.nextSibling;
          }
        }
      }
      if (faceOverlayLayer.parentNode !== parent || faceOverlayLayer.nextSibling !== reference) {
        parent.insertBefore(faceOverlayLayer, reference);
      }
    }

    function appendToFaceOverlay(element, targetGroupId = null) {
      if (!element) return null;
      element.style.pointerEvents = 'none';
      let target = faceOverlayLayer;
      if (targetGroupId) {
        ensureFaceOverlayGroups();
        target = ensureFaceOverlayGroup(targetGroupId) || faceOverlayLayer;
      }
      if (target && target.parentNode) {
        target.appendChild(element);
      } else if (faceOverlayLayer && faceOverlayLayer.parentNode) {
        faceOverlayLayer.appendChild(element);
      } else if (svgEl) {
        svgEl.appendChild(element);
      }
      positionFaceOverlayLayer();
      return element;
    }

    function createBrowHandler(options = {}) {
      const template = cloneTemplateNode(options.templateId || '');
      const path = template && template.tagName?.toLowerCase() === 'path'
        ? template
        : document.createElementNS(NS, 'path');
      applyTemplateStyles(template, path, ['stroke', 'stroke-width'], {
        stroke: options.stroke || '#362C3F',
        'stroke-width': options.strokeWidth ?? 8
      });
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('stroke-linejoin', 'round');
      appendToFaceOverlay(path, FACE_OVERLAY_SUBGROUP_IDS.brows);
      if (options.id && !path.id) path.id = options.id;

      const state = {
        base: Array.isArray(options.fallback)
          ? options.fallback.map((pt) => ({ x: pt.x, y: pt.y }))
          : null,
        smoothStart: null,
        smoothEnd: null,
        smoothPeak: null,
        archHeight: null,
        baseWidth: null,
        baseHeight: null
      };

      const captureBaseMetrics = (points) => {
        if (!Array.isArray(points) || points.length < 2) return;
        const start = points[0];
        const end = points[points.length - 1];
        if (!start || !end) return;
        const width = dist(start, end);
        if (!Number.isFinite(width) || width < 1e-3) return;
        const midPoint = mid(start, end);
        const candidates = points.slice(1, -1).filter(Boolean);
        const archPoint = candidates.length ? centroid(candidates) : midPoint;
        const vx = end.x - start.x;
        const vy = end.y - start.y;
        const len = Math.hypot(vx, vy) || 1;
        const nx = -vy / len;
        const ny = vx / len;
        const projection = (archPoint.x - midPoint.x) * nx + (archPoint.y - midPoint.y) * ny;
        state.baseWidth = width;
        state.baseHeight = Math.max(Math.abs(projection), width * 0.18);
      };

      if (state.base) {
        captureBaseMetrics(state.base);
      }

      const buildPath = (start, peak, end) => {
        const ctrlBias = 0.38;
        const ctrl1 = {
          x: start.x + (peak.x - start.x) * ctrlBias,
          y: start.y + (peak.y - start.y) * ctrlBias
        };
        const ctrl2 = {
          x: end.x + (peak.x - end.x) * ctrlBias,
          y: end.y + (peak.y - end.y) * ctrlBias
        };
        return [
          `M ${formatFloat(start.x)} ${formatFloat(start.y)}`,
          `C ${formatFloat(ctrl1.x)} ${formatFloat(ctrl1.y)} ${formatFloat(ctrl2.x)} ${formatFloat(ctrl2.y)} ${formatFloat(end.x)} ${formatFloat(end.y)}`
        ].join(' ');
      };

      return {
        el: path,
        setBase(points) {
          if (Array.isArray(points)) {
            state.base = points.map((pt) => ({ x: pt.x, y: pt.y }));
            captureBaseMetrics(state.base);
          }
        },
        update({ points, inverseMatrix, visible = true }) {
          if (!visible) {
            path.style.display = 'none';
            return;
          }
          const ptsGlobal = Array.isArray(points) && points.length >= 2 ? points : state.base;
          if (!Array.isArray(ptsGlobal) || ptsGlobal.length < 2) {
            path.style.display = 'none';
            return;
          }
          const local = inverseMatrix ? mapPoints(ptsGlobal, inverseMatrix) : ptsGlobal;
          const pts = Array.isArray(local) && local.length >= 2 ? local : state.base;
          if (!Array.isArray(pts) || pts.length < 2) {
            path.style.display = 'none';
            return;
          }
          const startRaw = pts[0];
          const endRaw = pts[pts.length - 1];
          if (!startRaw || !endRaw) {
            path.style.display = 'none';
            return;
          }
          const vx = endRaw.x - startRaw.x;
          const vy = endRaw.y - startRaw.y;
          const span = Math.hypot(vx, vy);
          if (span < 1e-2) {
            path.style.display = 'none';
            return;
          }
          const nx = -vy / span;
          const ny = vx / span;
          const midPoint = mid(startRaw, endRaw);
          const archCandidates = pts.slice(1, -1).filter(Boolean);
          const archCenter = archCandidates.length ? centroid(archCandidates) : midPoint;
          let projection = (archCenter.x - midPoint.x) * nx + (archCenter.y - midPoint.y) * ny;
          if (!Number.isFinite(projection)) projection = state.baseHeight ?? span * 0.22;
          const baseWidth = state.baseWidth ?? span;
          const baseHeight = state.baseHeight ?? span * 0.22;
          const minArch = Math.max(baseWidth * 0.16, baseHeight * 0.7);
          const maxArch = Math.max(baseWidth * 0.6, baseHeight * 1.8);
          const targetArch = clamp(Math.abs(projection), minArch, maxArch);
          state.archHeight = smoothScalar(state.archHeight, targetArch, 0.28);
          state.smoothStart = EMA(state.smoothStart, startRaw, 0.45);
          state.smoothEnd = EMA(state.smoothEnd, endRaw, 0.45);
          const start = state.smoothStart || startRaw;
          const end = state.smoothEnd || endRaw;
          const sx = end.x - start.x;
          const sy = end.y - start.y;
          const seg = Math.hypot(sx, sy);
          if (seg < 1e-2) {
            path.style.display = 'none';
            return;
          }
          const ux = sx / seg;
          const uy = sy / seg;
          const nux = -uy;
          const nuy = ux;
          const arch = state.archHeight || targetArch;
          const midPointSmooth = mid(start, end);
          const peakBase = {
            x: midPointSmooth.x + nux * arch,
            y: midPointSmooth.y + nuy * arch
          };
          state.smoothPeak = EMA(state.smoothPeak, peakBase, 0.32);
          const peak = state.smoothPeak || peakBase;
          const data = buildPath(start, peak, end);
          path.setAttribute('d', data);
          path.style.display = '';
        }
      };
    }

    function createEyeHandler(options = {}) {
      const template = cloneTemplateNode(options.templateId || '');
      const group = template && template.tagName?.toLowerCase() === 'g'
        ? template
        : document.createElementNS(NS, 'g');
      group.innerHTML = '';
      appendToFaceOverlay(group, FACE_OVERLAY_SUBGROUP_IDS.eyes);
      if (options.id) group.id = options.id;

      const sclera = document.createElementNS(NS, 'path');
      applyTemplateStyles(template, sclera, ['fill', 'stroke', 'stroke-width'], {
        fill: options.fill || '#FBFEFF',
        stroke: options.stroke || '#29303A',
        'stroke-width': options.strokeWidth ?? 3.2
      });
      sclera.setAttribute('stroke-linecap', 'round');
      sclera.setAttribute('stroke-linejoin', 'round');
      group.appendChild(sclera);

      const upperLid = document.createElementNS(NS, 'path');
      upperLid.setAttribute('fill', 'none');
      applyTemplateStyles(template, upperLid, ['stroke', 'stroke-width'], {
        stroke: options.lidStroke || '#1D2330',
        'stroke-width': options.lidStrokeWidth ?? 2.1
      });
      upperLid.setAttribute('stroke-linecap', 'round');
      upperLid.setAttribute('stroke-linejoin', 'round');
      group.appendChild(upperLid);

      const iris = document.createElementNS(NS, 'circle');
      applyTemplateStyles(template, iris, ['fill'], {
        fill: options.irisFill || '#6F8FB6'
      });
      iris.setAttribute('stroke', 'none');
      group.appendChild(iris);

      const pupil = document.createElementNS(NS, 'circle');
      applyTemplateStyles(template, pupil, ['fill'], {
        fill: options.pupilFill || '#141920'
      });
      pupil.setAttribute('stroke', 'none');
      group.appendChild(pupil);

      const highlight = document.createElementNS(NS, 'circle');
      highlight.setAttribute('fill', options.highlightFill || '#FFFFFF');
      highlight.setAttribute('opacity', options.highlightOpacity ?? 0.62);
      group.appendChild(highlight);

      const state = {
        base: Array.isArray(options.fallback)
          ? options.fallback.map((pt) => ({ x: pt.x, y: pt.y }))
          : null,
        center: null,
        rotation: null,
        width: null,
        height: null,
        baseWidth: null,
        baseHeight: null
      };

      const captureBaseMetrics = (points) => {
        if (!Array.isArray(points) || points.length < 4) return;
        const len = points.length;
        const outerCorner = points[0];
        const innerCorner = points[Math.floor(len / 2)];
        if (!outerCorner || !innerCorner) return;
        const topCandidates = [points[1], points[2]].filter(Boolean);
        const bottomCandidates = [points[len - 2], points[len - 1]].filter(Boolean);
        const topMid = topCandidates.length ? centroid(topCandidates) : mid(outerCorner, innerCorner);
        const bottomMid = bottomCandidates.length ? centroid(bottomCandidates) : topMid;
        state.baseWidth = dist(outerCorner, innerCorner);
        state.baseHeight = dist(topMid, bottomMid);
      };

      if (state.base) {
        captureBaseMetrics(state.base);
      }

      return {
        el: group,
        setBase(points) {
          if (Array.isArray(points)) {
            state.base = points.map((pt) => ({ x: pt.x, y: pt.y }));
            captureBaseMetrics(state.base);
          }
        },
        update({ points, inverseMatrix, visible = true }) {
          if (!visible) {
            group.style.display = 'none';
            return;
          }
          const ptsRaw = Array.isArray(points) && points.length ? points : state.base;
          if (!Array.isArray(ptsRaw) || ptsRaw.length < 4) {
            group.style.display = 'none';
            return;
          }
          const localRaw = inverseMatrix ? mapPoints(ptsRaw, inverseMatrix) : ptsRaw;
          const pts = normalizeLoopPoints(localRaw || []);
          if (!Array.isArray(pts) || pts.length < 4) {
            group.style.display = 'none';
            return;
          }
          const len = pts.length;
          const outerCorner = pts[0];
          const innerCorner = pts[Math.floor(len / 2)];
          if (!outerCorner || !innerCorner) {
            group.style.display = 'none';
            return;
          }
          const topCandidates = [pts[1], pts[2]].filter(Boolean);
          const bottomCandidates = [pts[len - 2], pts[len - 1]].filter(Boolean);
          const topMid = topCandidates.length ? centroid(topCandidates) : mid(outerCorner, innerCorner);
          const bottomMid = bottomCandidates.length ? centroid(bottomCandidates) : topMid;
          const rawCenter = mid(outerCorner, innerCorner);
          const rawWidth = dist(outerCorner, innerCorner);
          const verticalSpan = dist(topMid, bottomMid);
          const baseWidth = state.baseWidth ?? rawWidth;
          const width = clamp(rawWidth, baseWidth * 0.65, baseWidth * 1.45);
          const desiredHeight = clamp(verticalSpan * 0.85, width * 0.24, width * 0.48);
          const baseHeight = state.baseHeight ?? desiredHeight;
          const clampedHeight = clamp(desiredHeight, baseHeight * 0.7, baseHeight * 1.35);
          const rawAngle = Math.atan2(innerCorner.y - outerCorner.y, innerCorner.x - outerCorner.x);
          state.center = EMA(state.center, rawCenter, 0.4);
          state.width = smoothScalar(state.width, width, 0.32);
          state.height = smoothScalar(state.height, clampedHeight, 0.32);
          state.rotation = smoothAngle(state.rotation, rawAngle, 0.28);
          const center = state.center || rawCenter;
          const smoothedWidth = state.width || width;
          const smoothedHeight = state.height || clampedHeight;
          const openness = clamp(smoothedHeight / Math.max(smoothedWidth, 1), 0, 1);
          const halfW = smoothedWidth / 2;
          const halfH = smoothedHeight / 2;
          const ctrlX = halfW * 0.68;
          const ctrlY = halfH * 1.15;
          const pathData = [
            `M ${formatFloat(-halfW)} 0`,
            `C ${formatFloat(-halfW + ctrlX)} ${formatFloat(-ctrlY)} ${formatFloat(halfW - ctrlX)} ${formatFloat(-ctrlY)} ${formatFloat(halfW)} 0`,
            `C ${formatFloat(halfW - ctrlX)} ${formatFloat(ctrlY)} ${formatFloat(-halfW + ctrlX)} ${formatFloat(ctrlY)} ${formatFloat(-halfW)} 0`,
            'Z'
          ].join(' ');
          const lidCtrlY = ctrlY * 0.82;
          const lidPath = [
            `M ${formatFloat(-halfW)} 0`,
            `C ${formatFloat(-halfW + ctrlX * 0.9)} ${formatFloat(-lidCtrlY)} ${formatFloat(halfW - ctrlX * 0.9)} ${formatFloat(-lidCtrlY)} ${formatFloat(halfW)} 0`
          ].join(' ');
          sclera.setAttribute('d', pathData);
          upperLid.setAttribute('d', lidPath);
          const rotation = state.rotation || rawAngle || 0;
          group.setAttribute(
            'transform',
            `translate(${formatFloat(center.x)} ${formatFloat(center.y)}) rotate(${formatFloat((rotation * 180) / Math.PI)})`
          );
          const irisRadius = clamp(smoothedWidth * 0.24, 1.4, smoothedHeight * 0.9);
          const pupilRadius = clamp(irisRadius * 0.48, 0.8, irisRadius * 0.82);
          const pupilOffsetY = smoothedHeight * 0.08;
          iris.setAttribute('cx', '0');
          iris.setAttribute('cy', formatFloat(pupilOffsetY));
          iris.setAttribute('r', formatFloat(irisRadius));
          pupil.setAttribute('cx', '0');
          pupil.setAttribute('cy', formatFloat(pupilOffsetY + smoothedHeight * 0.02));
          pupil.setAttribute('r', formatFloat(pupilRadius));
          const highlightRadius = pupilRadius * 0.48;
          const highlightOffset = irisRadius * 0.42;
          highlight.setAttribute('cx', formatFloat(-highlightOffset));
          highlight.setAttribute('cy', formatFloat(pupilOffsetY - highlightOffset * 0.55));
          highlight.setAttribute('r', formatFloat(highlightRadius));
          const showInner = openness > 0.1;
          iris.style.display = showInner ? 'block' : 'none';
          pupil.style.display = showInner ? 'block' : 'none';
          highlight.style.display = openness > 0.18 && highlightRadius > 0.6 ? 'block' : 'none';
          group.style.display = '';
        }
      };
    }

    function createSkinHandler(options = {}) {
      const group = document.createElementNS(NS, 'g');
      group.style.display = 'none';
      appendToFaceOverlay(group, FACE_OVERLAY_SUBGROUP_IDS.skin);
      if (options.id) group.id = options.id;

      const baseColor = options.baseColor || '#F3AF9D';
      const jawStrokeColor = options.jawStroke || mixHex(baseColor, '#D98E7E', 0.25);
      const blushWarm = options.blushTarget || '#FFBFAF';
      const blushHighlight = options.blushHighlight || '#FFE8DE';
      const blushFill = options.blushFill || mixHex(mixHex(baseColor, blushWarm, 0.18), blushHighlight, 0.4);
      const part = options.part || 'jaw';

      let element = null;
      if (part === 'jaw') {
        element = document.createElementNS(NS, 'path');
        element.setAttribute('fill', 'none');
        element.setAttribute('stroke', jawStrokeColor);
        element.setAttribute('stroke-width', options.strokeWidth ?? 6.2);
        element.setAttribute('stroke-linecap', 'round');
        element.setAttribute('stroke-linejoin', 'round');
        element.setAttribute('opacity', options.opacity ?? 0.85);
        element.style.pointerEvents = 'none';
        group.appendChild(element);
      } else if (part === 'cheek') {
        element = document.createElementNS(NS, 'ellipse');
        element.setAttribute('fill', blushFill);
        element.setAttribute('stroke', 'none');
        element.setAttribute('opacity', options.opacity ?? 0.32);
        element.style.pointerEvents = 'none';
        group.appendChild(element);
      } else {
        element = document.createElementNS(NS, 'g');
        element.style.pointerEvents = 'none';
        group.appendChild(element);
      }

      const state = {
        base: Array.isArray(options.fallback)
          ? options.fallback.map((pt) => ({ x: pt.x, y: pt.y }))
          : null,
        smooth: null,
        bounds: null,
        center: null,
        rx: null,
        ry: null,
        angle: null,
        baseEyeMouth: null
      };

      const ensureBounds = (contourPoints) => {
        if (Array.isArray(contourPoints) && contourPoints.length) {
          let minX = Number.POSITIVE_INFINITY;
          let minY = Number.POSITIVE_INFINITY;
          let maxX = Number.NEGATIVE_INFINITY;
          let maxY = Number.NEGATIVE_INFINITY;
          for (const pt of contourPoints) {
            if (!pt) continue;
            const { x, y } = pt;
            if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
          if (minX <= maxX && minY <= maxY) {
            state.bounds = { minX, minY, maxX, maxY };
          }
        }
        return state.bounds;
      };

      const clampPointToBounds = (pt, bounds, inset = 0) => {
        if (!bounds || !pt) return pt;
        return {
          x: clamp(pt.x, bounds.minX + inset, bounds.maxX - inset),
          y: clamp(pt.y, bounds.minY + inset, bounds.maxY - inset)
        };
      };

      const computeCheekCenter = (pts) => {
        if (!Array.isArray(pts) || pts.length < 3) return null;
        const [eye, mouth, jaw] = pts;
        if (!eye || !mouth || !jaw) return null;
        const upper = midpoint(eye, mouth) || mouth;
        const lower = midpoint(mouth, jaw) || mouth;
        return {
          x: upper.x * 0.42 + lower.x * 0.58,
          y: upper.y * 0.28 + lower.y * 0.72
        };
      };

      const hide = () => {
        group.style.display = 'none';
        if (!element) return;
        element.style.display = 'none';
        element.removeAttribute('transform');
        if (part === 'jaw') {
          element.setAttribute('d', '');
        }
      };

      const updateJaw = (sourcePoints, contourPoints) => {
        const bounds = ensureBounds(contourPoints);
        const pts = Array.isArray(sourcePoints) && sourcePoints.length
          ? sourcePoints
          : state.base;
        if (!Array.isArray(pts) || pts.length < 3) {
          hide();
          return;
        }
        if (!Array.isArray(state.smooth)) {
          state.smooth = pts.map((pt) => (pt ? { x: pt.x, y: pt.y } : null));
        }
        const margin = options.boundsInset ?? 2.4;
        const smoothed = [];
        for (let i = 0; i < pts.length; i += 1) {
          const raw = pts[i];
          if (!raw) continue;
          const clamped = clampPointToBounds({ x: raw.x, y: raw.y }, bounds, margin);
          const prev = state.smooth[i];
          const next = prev
            ? {
              x: prev.x + 0.32 * (clamped.x - prev.x),
              y: prev.y + 0.32 * (clamped.y - prev.y)
            }
            : clamped;
          state.smooth[i] = next;
          smoothed.push(next);
        }
        if (smoothed.length < 3) {
          hide();
          return;
        }
        const pathPoints = smoothed.filter(Boolean);
        if (pathPoints.length < 3) {
          hide();
          return;
        }
        const pathData = buildSmoothPath(pathPoints, { closed: false, tension: 0.52 });
        element.setAttribute('d', pathData);
        element.style.display = '';
        group.style.display = '';
      };

      const updateCheek = (sourcePoints, contourPoints) => {
        const bounds = ensureBounds(contourPoints) || state.bounds;
        const pts = Array.isArray(sourcePoints) && sourcePoints.length >= 3
          ? sourcePoints
          : state.base;
        if (!Array.isArray(pts) || pts.length < 3) {
          hide();
          return;
        }
        const [eye, mouth] = pts;
        const distance = eye && mouth ? dist(eye, mouth) : null;
        if (!Number.isFinite(distance) || distance < 1e-2) {
          hide();
          return;
        }
        if (state.baseEyeMouth == null) state.baseEyeMouth = distance;
        const baseSpan = state.baseEyeMouth || distance;
        const span = clamp(distance, baseSpan * 0.7, baseSpan * 1.35);
        const rxTarget = clamp(span * 0.45, 5, bounds ? (bounds.maxX - bounds.minX) * 0.45 : span);
        const ryTarget = clamp(span * 0.34, 4, bounds ? (bounds.maxY - bounds.minY) * 0.4 : span * 0.6);
        state.rx = smoothScalar(state.rx, rxTarget, 0.3);
        state.ry = smoothScalar(state.ry, ryTarget, 0.3);
        const rawCenter = computeCheekCenter(pts);
        if (!rawCenter) {
          hide();
          return;
        }
        const rx = Math.max(state.rx ?? rxTarget, 1);
        const ry = Math.max(state.ry ?? ryTarget, 1);
        rawCenter.x += (options.side === 'left' ? 1 : -1) * rx * 0.18;
        const paddedX = rx * 1.05;
        const paddedY = ry * 1.05;
        const clampedCenter = bounds
          ? {
            x: clamp(rawCenter.x, bounds.minX + paddedX, bounds.maxX - paddedX),
            y: clamp(rawCenter.y, bounds.minY + paddedY, bounds.maxY - paddedY)
          }
          : rawCenter;
        state.center = state.center ? EMA(state.center, clampedCenter, 0.34) : clampedCenter;
        const center = state.center;
        if (!center) {
          hide();
          return;
        }
        const angleRaw = mouth && eye ? Math.atan2(mouth.y - eye.y, mouth.x - eye.x) : 0;
        state.angle = smoothAngle(state.angle, angleRaw, 0.26);
        element.setAttribute('cx', formatFloat(center.x));
        element.setAttribute('cy', formatFloat(center.y));
        element.setAttribute('rx', formatFloat(rx));
        element.setAttribute('ry', formatFloat(ry));
        if (Number.isFinite(state.angle ?? angleRaw)) {
          const deg = ((state.angle ?? angleRaw) * 180) / Math.PI;
          element.setAttribute('transform', `rotate(${formatFloat(deg)} ${formatFloat(center.x)} ${formatFloat(center.y)})`);
        } else {
          element.removeAttribute('transform');
        }
        element.style.display = '';
        group.style.display = '';
      };

      return {
        el: group,
        setBase(points) {
          if (!Array.isArray(points)) return;
          state.base = points.map((pt) => ({ x: pt.x, y: pt.y }));
          if (part === 'jaw') {
            state.smooth = state.base.map((pt) => (pt ? { x: pt.x, y: pt.y } : null));
          } else if (part === 'cheek') {
            if (state.base.length >= 2) {
              const [eye, mouth] = state.base;
              const baseDist = eye && mouth ? dist(eye, mouth) : null;
              if (Number.isFinite(baseDist)) state.baseEyeMouth = baseDist;
            }
            const baseCenter = computeCheekCenter(state.base);
            if (baseCenter) state.center = { ...baseCenter };
          }
        },
        update({ points, fallback, visible = true, contourFallback, contourTarget }) {
          if (!visible) {
            hide();
            return;
          }
          const contourPoints = contourTarget?.length ? contourTarget : contourFallback;
          const source = Array.isArray(points) && points.length ? points : fallback;
          if (part === 'jaw') {
            updateJaw(source, contourPoints);
          } else if (part === 'cheek') {
            updateCheek(source, contourPoints);
          } else {
            hide();
          }
        }
      };
    }

    function createNoseHandler(options = {}) {
      const template = cloneTemplateNode(options.templateId || '');
      const group = template && template.tagName?.toLowerCase() === 'g'
        ? template
        : document.createElementNS(NS, 'g');
      const templatePath = template ? template.querySelector('path') : null;
      group.innerHTML = '';
      appendToFaceOverlay(group, FACE_OVERLAY_SUBGROUP_IDS.nose);
      if (options.id) group.id = options.id;

      const bridge = document.createElementNS(NS, 'path');
      applyTemplateStyles(templatePath, bridge, ['stroke', 'stroke-width'], {
        stroke: options.stroke || '#2C323A',
        'stroke-width': options.bridgeWidth ?? 2.6
      });
      bridge.setAttribute('fill', 'none');
      bridge.setAttribute('stroke-linecap', 'round');
      bridge.setAttribute('stroke-linejoin', 'round');
      bridge.style.display = 'none';
      group.appendChild(bridge);

      const tip = document.createElementNS(NS, 'path');
      applyTemplateStyles(templatePath, tip, ['stroke', 'stroke-width'], {
        stroke: options.stroke || '#2C323A',
        'stroke-width': options.tipStrokeWidth ?? 2.8
      });
      tip.setAttribute('fill', 'none');
      tip.setAttribute('stroke-linecap', 'round');
      tip.setAttribute('stroke-linejoin', 'round');
      tip.style.display = 'none';
      group.appendChild(tip);

      const nostrilLeft = document.createElementNS(NS, 'path');
      const nostrilRight = document.createElementNS(NS, 'path');
      [nostrilLeft, nostrilRight].forEach((nostril) => {
        applyTemplateStyles(templatePath, nostril, ['stroke', 'stroke-width'], {
          stroke: options.stroke || '#2C323A',
          'stroke-width': options.nostrilStrokeWidth ?? 2.2
        });
        nostril.setAttribute('fill', 'none');
        nostril.setAttribute('stroke-linecap', 'round');
        nostril.setAttribute('stroke-linejoin', 'round');
        nostril.style.display = 'none';
        group.appendChild(nostril);
      });

      const initialPart = options.part || 'default';
      const state = {
        base: {},
        parts: {
          bridge: null,
          base: null
        },
        center: null,
        rotation: null,
        bridgeHeight: null,
        width: null,
        tipWidth: null,
        tipHeight: null,
        nostrilGap: null,
        nostrilWidth: null,
        baseWidth: null,
        baseBridge: null
      };
      if (Array.isArray(options.fallback)) {
        state.base[initialPart] = options.fallback.map((pt) => ({ x: pt.x, y: pt.y }));
      }

      const refresh = () => {
        const bridgeData = state.parts.bridge;
        const baseData = state.parts.base;
        const bridgePoints = bridgeData?.points || null;
        const basePoints = baseData?.points || null;

        let rawCenter = null;
        if (basePoints && basePoints.length >= 3 && basePoints[2]) {
          rawCenter = basePoints[2];
        } else if (bridgePoints && bridgePoints.length) {
          rawCenter = bridgePoints[bridgePoints.length - 1];
        }

        let axisLen = null;
        if (bridgePoints && bridgePoints.length >= 2) {
          const tipPt = bridgePoints[bridgePoints.length - 1];
          const topCandidates = bridgePoints.slice(0, -1).filter(Boolean);
          const topPt = topCandidates.length ? centroid(topCandidates) : bridgePoints[0];
          if (tipPt && topPt) {
            const axisVec = { x: tipPt.x - topPt.x, y: tipPt.y - topPt.y };
            const length = Math.hypot(axisVec.x, axisVec.y);
            if (Number.isFinite(length) && length > 1e-3) {
              axisLen = length;
              if (state.baseBridge == null) state.baseBridge = length;
              const rawRotation = Math.atan2(axisVec.y, axisVec.x) - Math.PI / 2;
              state.rotation = smoothAngle(state.rotation, rawRotation, 0.32);
              const minBridge = (state.baseBridge ?? length) * 0.65;
              const maxBridge = (state.baseBridge ?? length) * 1.35;
              const bridgeTarget = clamp(length, minBridge, maxBridge);
              state.bridgeHeight = smoothScalar(state.bridgeHeight, bridgeTarget, 0.32);
            }
          }
        }

        if (rawCenter) {
          state.center = state.center ? EMA(state.center, rawCenter, 0.35) : rawCenter;
        }

        if (basePoints && basePoints.length >= 5) {
          const rightOuter = basePoints[0];
          const rightInner = basePoints[1];
          const leftInner = basePoints[3];
          const leftOuter = basePoints[4];
          const rawWidth = dist(rightOuter, leftOuter);
          if (Number.isFinite(rawWidth) && rawWidth > 1e-3) {
            if (state.baseWidth == null) state.baseWidth = rawWidth;
            const minWidth = (state.baseWidth ?? rawWidth) * 0.8;
            const maxWidth = (state.baseWidth ?? rawWidth) * 1.3;
            const widthTarget = clamp(rawWidth, minWidth, maxWidth);
            state.width = smoothScalar(state.width, widthTarget, 0.28);
            const nostrilSpanRaw = dist(rightInner, leftInner);
            const nostrilSpan = clamp(nostrilSpanRaw, widthTarget * 0.3, widthTarget * 0.75);
            state.nostrilGap = smoothScalar(state.nostrilGap, nostrilSpan, 0.3);
            const nostrilWidthRaw = (dist(rightOuter, rightInner) + dist(leftOuter, leftInner)) / 2;
            const nostrilWidthTarget = clamp(nostrilWidthRaw, widthTarget * 0.12, widthTarget * 0.28);
            state.nostrilWidth = smoothScalar(state.nostrilWidth, nostrilWidthTarget, 0.3);
            const tipSpan = clamp(widthTarget * 0.55, widthTarget * 0.38, widthTarget * 0.7);
            state.tipWidth = smoothScalar(state.tipWidth, tipSpan, 0.28);
            const referenceBridge = state.bridgeHeight ?? axisLen ?? state.baseBridge ?? widthTarget * 1.1;
            const tipHeightTarget = clamp(referenceBridge * 0.28, 4, widthTarget * 0.7);
            state.tipHeight = smoothScalar(state.tipHeight, tipHeightTarget, 0.3);
          }
        }

        const center = state.center || rawCenter;
        let rotation = state.rotation ?? 0;
        if (!center || !Number.isFinite(rotation)) {
          group.style.display = 'none';
          return;
        }

        const widthVal = state.width ?? state.baseWidth ?? 14;
        const halfWidth = widthVal / 2;
        const tipWidth = clamp(state.tipWidth ?? widthVal * 0.5, widthVal * 0.3, widthVal * 0.72);
        const tipHeight = clamp(state.tipHeight ?? (state.bridgeHeight || widthVal) * 0.26, widthVal * 0.12, widthVal * 0.78);
        const bridgeHeight = clamp(state.bridgeHeight ?? (axisLen || widthVal) * 0.9, tipHeight * 1.3, (state.baseBridge ?? widthVal * 1.4) * 1.4);
        const nostrilGap = clamp(state.nostrilGap ?? widthVal * 0.42, widthVal * 0.24, widthVal * 0.78);
        const nostrilHalf = nostrilGap / 2;
        const nostrilWidth = clamp(state.nostrilWidth ?? widthVal * 0.18, widthVal * 0.1, widthVal * 0.32);
        const nostrilRise = Math.max(nostrilWidth * 0.65, tipHeight * 0.4);

        group.setAttribute(
          'transform',
          `translate(${formatFloat(center.x)} ${formatFloat(center.y)}) rotate(${formatFloat((rotation * 180) / Math.PI)})`
        );

        let anyVisible = false;
        if (bridgePoints && bridgeHeight > 0.6) {
          const blend = Math.min(tipHeight * 0.7, bridgeHeight * 0.45);
          const sway = tipWidth * 0.08;
          const bridgePath = [
            `M ${formatFloat(-sway)} ${formatFloat(-bridgeHeight)}`,
            `Q 0 ${formatFloat(-bridgeHeight + blend * 0.35)} 0 ${formatFloat(-blend)}`,
            `Q 0 ${formatFloat(-blend * 0.35)} 0 ${formatFloat(-Math.max(blend * 0.12, 0.4))}`
          ].join(' ');
          bridge.setAttribute('d', bridgePath);
          bridge.style.display = '';
          anyVisible = true;
        } else {
          bridge.style.display = 'none';
        }

        if (basePoints && tipWidth > 0.6 && tipHeight > 0.6) {
          const halfTip = tipWidth / 2;
          const tipPath = [
            `M ${formatFloat(-halfTip)} 0`,
            `Q ${formatFloat(-halfTip * 0.4)} ${formatFloat(tipHeight * 0.28)} 0 ${formatFloat(tipHeight)}`,
            `Q ${formatFloat(halfTip * 0.4)} ${formatFloat(tipHeight * 0.28)} ${formatFloat(halfTip)} 0`
          ].join(' ');
          tip.setAttribute('d', tipPath);
          tip.style.display = '';
          anyVisible = true;
        } else {
          tip.style.display = 'none';
        }

        if (basePoints && nostrilHalf > 0.3 && nostrilWidth > 0.3) {
          const nostrilY = tipHeight * 0.55;
          const buildNostril = (dir) => {
            const cx = dir * nostrilHalf;
            const startX = cx - nostrilWidth / 2;
            const endX = cx + nostrilWidth / 2;
            return [
              `M ${formatFloat(startX)} ${formatFloat(nostrilY)}`,
              `Q ${formatFloat(cx)} ${formatFloat(nostrilY + nostrilRise)} ${formatFloat(endX)} ${formatFloat(nostrilY)}`
            ].join(' ');
          };
          nostrilLeft.setAttribute('d', buildNostril(-1));
          nostrilRight.setAttribute('d', buildNostril(1));
          nostrilLeft.style.display = '';
          nostrilRight.style.display = '';
          anyVisible = true;
        } else {
          nostrilLeft.style.display = 'none';
          nostrilRight.style.display = 'none';
        }

        group.style.display = anyVisible ? '' : 'none';
      };

      return {
        el: group,
        setBase(points, partArg) {
          const key = partArg || options.part || 'default';
          if (Array.isArray(points)) {
            state.base[key] = points.map((pt) => ({ x: pt.x, y: pt.y }));
          }
        },
        update({ points, part, inverseMatrix, visible = true, ids = [] }) {
          const mode = part || options.part || 'default';
          const assignPart = (value) => {
            state.parts[mode === 'base' ? 'base' : 'bridge'] = value;
          };

          if (!visible) {
            assignPart(null);
            if (mode === 'base') {
              tip.style.display = 'none';
              nostrilLeft.style.display = 'none';
              nostrilRight.style.display = 'none';
            } else {
              bridge.style.display = 'none';
            }
            if (!state.parts.base && !state.parts.bridge) {
              group.style.display = 'none';
            } else {
              refresh();
            }
            return;
          }

          const sourcePoints = Array.isArray(points) && points.length ? points : state.base[mode];
          if (!Array.isArray(sourcePoints) || !sourcePoints.length) {
            assignPart(null);
            if (mode === 'base') {
              tip.style.display = 'none';
              nostrilLeft.style.display = 'none';
              nostrilRight.style.display = 'none';
            } else {
              bridge.style.display = 'none';
            }
            if (!state.parts.base && !state.parts.bridge) group.style.display = 'none';
            return;
          }

          const mapped = inverseMatrix ? mapPoints(sourcePoints, inverseMatrix) : sourcePoints;
          if (!Array.isArray(mapped) || !mapped.length) {
            assignPart(null);
            if (mode === 'base') {
              tip.style.display = 'none';
              nostrilLeft.style.display = 'none';
              nostrilRight.style.display = 'none';
            } else {
              bridge.style.display = 'none';
            }
            if (!state.parts.base && !state.parts.bridge) group.style.display = 'none';
            return;
          }

          const processed = mapped.map((pt) => ({ x: pt.x, y: pt.y }));
          assignPart({
            points: processed,
            ids: Array.isArray(ids) ? ids.slice() : []
          });
          refresh();
        }
      };
    }

    function createMouthHandler(options = {}) {
      const template = cloneTemplateNode(options.templateId || '');
      const group = template && template.tagName?.toLowerCase() === 'g'
        ? template
        : document.createElementNS(NS, 'g');
      const templatePath = template ? template.querySelector('path') : null;
      group.innerHTML = '';
      appendToFaceOverlay(group, FACE_OVERLAY_SUBGROUP_IDS.mouth);
      if (options.id) group.id = options.id;

      const outer = document.createElementNS(NS, 'path');
      applyTemplateStyles(templatePath, outer, ['fill', 'stroke', 'stroke-width'], {
        fill: options.outerFill || '#F1B1AC',
        stroke: options.outerStroke || '#C97877',
        'stroke-width': options.outerStrokeWidth ?? 2.6
      });
      outer.setAttribute('stroke-linecap', 'round');
      outer.setAttribute('stroke-linejoin', 'round');
      group.appendChild(outer);

      const inner = document.createElementNS(NS, 'path');
      inner.setAttribute('fill', options.innerFill || '#8F4A49');
      inner.setAttribute('stroke', 'none');
      inner.style.opacity = options.innerOpacity ?? 0.82;
      inner.style.display = 'none';
      group.appendChild(inner);

      const initialPart = options.part || 'default';
      const state = {
        base: {},
        parts: {
          outer: null,
          inner: null
        },
        center: null,
        rotation: null,
        width: null,
        upperHeight: null,
        lowerHeight: null,
        opening: null,
        innerWidth: null,
        baseWidth: null,
        baseUpper: null,
        baseLower: null,
        baseGap: null
      };
      if (Array.isArray(options.fallback)) {
        state.base[initialPart] = options.fallback.map((pt) => ({ x: pt.x, y: pt.y }));
      }

      const refresh = () => {
        const outerData = state.parts.outer;
        const innerData = state.parts.inner;
        const outerPoints = outerData?.points || null;
        const outerIds = outerData?.ids || [];
        if (!outerPoints || outerPoints.length < 4) {
          group.style.display = 'none';
          inner.style.display = 'none';
          return;
        }

        const named = {};
        outerIds.forEach((id, idx) => {
          named[id] = outerPoints[idx];
        });

        const rightCorner = named.rightMouthCorner || outerPoints[0];
        const leftCorner = named.leftMouthCorner || outerPoints.find((pt, idx) => outerIds[idx] === 'leftMouthCorner') || outerPoints[outerPoints.length - 1];
        if (!rightCorner || !leftCorner) {
          group.style.display = 'none';
          inner.style.display = 'none';
          return;
        }

        const widthVec = { x: leftCorner.x - rightCorner.x, y: leftCorner.y - rightCorner.y };
        const rawWidth = Math.hypot(widthVec.x, widthVec.y);
        if (!Number.isFinite(rawWidth) || rawWidth < 1e-3) {
          group.style.display = 'none';
          inner.style.display = 'none';
          return;
        }

        const widthUnit = { x: widthVec.x / rawWidth, y: widthVec.y / rawWidth };
        const perpUnit = { x: -widthUnit.y, y: widthUnit.x };
        const mid = {
          x: (leftCorner.x + rightCorner.x) / 2,
          y: (leftCorner.y + rightCorner.y) / 2
        };
        state.center = state.center ? EMA(state.center, mid, 0.4) : mid;
        if (state.baseWidth == null) state.baseWidth = rawWidth;
        const minWidth = (state.baseWidth ?? rawWidth) * 0.75;
        const maxWidth = (state.baseWidth ?? rawWidth) * 1.35;
        const widthTarget = clamp(rawWidth, minWidth, maxWidth);
        state.width = smoothScalar(state.width, widthTarget, 0.3);
        const rotationRaw = Math.atan2(widthUnit.y, widthUnit.x);
        state.rotation = smoothAngle(state.rotation, rotationRaw, 0.28);

        const center = state.center || mid;
        const project = (pt) => {
          const dx = pt.x - center.x;
          const dy = pt.y - center.y;
          return {
            x: dx * widthUnit.x + dy * widthUnit.y,
            y: dx * perpUnit.x + dy * perpUnit.y
          };
        };

        const upperOuter = named.upperLipTopMid ? project(named.upperLipTopMid) : null;
        const lowerOuter = named.lowerLipBottomMid ? project(named.lowerLipBottomMid) : null;
        if (upperOuter) {
          const upperTarget = clamp(-upperOuter.y, widthTarget * 0.08, widthTarget * 0.35);
          state.upperHeight = smoothScalar(state.upperHeight, upperTarget, 0.32);
          if (state.baseUpper == null) state.baseUpper = upperTarget;
        } else if (state.baseUpper != null) {
          state.upperHeight = smoothScalar(state.upperHeight, state.baseUpper, 0.2);
        }
        if (lowerOuter) {
          const lowerTarget = clamp(lowerOuter.y, widthTarget * 0.1, widthTarget * 0.42);
          state.lowerHeight = smoothScalar(state.lowerHeight, lowerTarget, 0.32);
          if (state.baseLower == null) state.baseLower = lowerTarget;
        } else if (state.baseLower != null) {
          state.lowerHeight = smoothScalar(state.lowerHeight, state.baseLower, 0.2);
        }

        let gapTarget = null;
        let innerWidthTarget = null;
        if (innerData?.points?.length) {
          const innerNamed = {};
          innerData.ids.forEach((id, idx) => {
            innerNamed[id] = innerData.points[idx];
          });
          const upperInner = innerNamed.upperLipBottomMid ? project(innerNamed.upperLipBottomMid) : null;
          const lowerInner = innerNamed.lowerLipTopMid ? project(innerNamed.lowerLipTopMid) : null;
          if (upperInner && lowerInner) {
            const rawGap = Math.max(lowerInner.y - upperInner.y, 0);
            if (state.baseGap == null) state.baseGap = rawGap;
            const minGap = Math.max((state.baseGap ?? rawGap) * 0.25, widthTarget * 0.02);
            const maxGap = Math.max((state.baseGap ?? rawGap) * 2.2, widthTarget * 0.55);
            gapTarget = clamp(rawGap, minGap, maxGap);
          }
          const innerLeft = innerNamed.leftMouthCorner ? project(innerNamed.leftMouthCorner) : null;
          const innerRight = innerNamed.rightMouthCorner ? project(innerNamed.rightMouthCorner) : null;
          if (innerLeft && innerRight) {
            const rawInnerWidth = Math.abs(innerRight.x - innerLeft.x);
            innerWidthTarget = clamp(rawInnerWidth, widthTarget * 0.5, widthTarget * 0.9);
          }
        }

        if (gapTarget == null) {
          const baseGap = state.baseGap ?? (state.baseLower ?? widthTarget * 0.22) * 0.4;
          gapTarget = clamp(baseGap, widthTarget * 0.015, widthTarget * 0.45);
        }
        state.opening = smoothScalar(state.opening, gapTarget, 0.3);
        if (innerWidthTarget != null) {
          state.innerWidth = smoothScalar(state.innerWidth, innerWidthTarget, 0.3);
        } else if (state.innerWidth == null) {
          state.innerWidth = widthTarget * 0.68;
        }

        const rotation = state.rotation ?? rotationRaw;
        if (!center || !Number.isFinite(rotation)) {
          group.style.display = 'none';
          inner.style.display = 'none';
          return;
        }

        const widthVal = state.width ?? widthTarget;
        const halfWidth = widthVal / 2;
        const upperHeight = clamp(state.upperHeight ?? (state.baseUpper ?? widthVal * 0.2), widthVal * 0.08, widthVal * 0.36);
        const lowerHeight = clamp(state.lowerHeight ?? (state.baseLower ?? widthVal * 0.24), widthVal * 0.1, widthVal * 0.45);
        const cupidWidth = clamp(widthVal * 0.42, widthVal * 0.3, widthVal * 0.58);
        const opening = Math.max(state.opening ?? 0, 0);
        const innerHalf = opening / 2;
        const innerSpan = clamp(state.innerWidth ?? widthVal * 0.68, widthVal * 0.4, widthVal * 0.92);

        group.setAttribute(
          'transform',
          `translate(${formatFloat(center.x)} ${formatFloat(center.y)}) rotate(${formatFloat((rotation * 180) / Math.PI)})`
        );
        group.style.display = '';

        const outerPath = [
          `M ${formatFloat(-halfWidth)} 0`,
          `C ${formatFloat(-halfWidth * 0.55)} ${formatFloat(-upperHeight * 0.15)} ${formatFloat(-cupidWidth)} ${formatFloat(-upperHeight)} 0 ${formatFloat(-upperHeight)}`,
          `C ${formatFloat(cupidWidth)} ${formatFloat(-upperHeight)} ${formatFloat(halfWidth * 0.55)} ${formatFloat(-upperHeight * 0.15)} ${formatFloat(halfWidth)} 0`,
          `C ${formatFloat(halfWidth * 0.55)} ${formatFloat(lowerHeight * 0.22)} ${formatFloat(cupidWidth)} ${formatFloat(lowerHeight)} 0 ${formatFloat(lowerHeight)}`,
          `C ${formatFloat(-cupidWidth)} ${formatFloat(lowerHeight)} ${formatFloat(-halfWidth * 0.55)} ${formatFloat(lowerHeight * 0.22)} ${formatFloat(-halfWidth)} 0`,
          'Z'
        ].join(' ');
        outer.setAttribute('d', outerPath);

        if (opening > widthVal * 0.02) {
          const innerHalfWidth = Math.max(innerSpan / 2, halfWidth * 0.42);
          const cappedHalf = Math.max(innerHalf, widthVal * 0.012);
          const innerPath = [
            `M ${formatFloat(-innerHalfWidth)} ${formatFloat(-cappedHalf)}`,
            `Q 0 ${formatFloat(-cappedHalf * 0.45)} ${formatFloat(innerHalfWidth)} ${formatFloat(-cappedHalf)}`,
            `Q ${formatFloat(innerHalfWidth * 0.7)} ${formatFloat(cappedHalf)} ${formatFloat(innerHalfWidth)} ${formatFloat(cappedHalf)}`,
            `Q 0 ${formatFloat(cappedHalf * 0.45)} ${formatFloat(-innerHalfWidth)} ${formatFloat(cappedHalf)}`,
            'Z'
          ].join(' ');
          inner.setAttribute('d', innerPath);
          inner.style.display = '';
        } else {
          inner.style.display = 'none';
        }
      };

      return {
        el: group,
        setBase(points, partArg) {
          const key = partArg || options.part || 'default';
          if (Array.isArray(points)) {
            state.base[key] = points.map((pt) => ({ x: pt.x, y: pt.y }));
          }
        },
        update({ points, part, inverseMatrix, visible = true, ids = [] }) {
          const mode = (part || options.part) === 'inner' ? 'inner' : 'outer';
          const assignPart = (value) => {
            state.parts[mode] = value;
          };

          if (!visible) {
            assignPart(null);
            if (mode === 'inner') {
              inner.style.display = 'none';
            } else {
              group.style.display = 'none';
            }
            refresh();
            return;
          }

          const source = Array.isArray(points) && points.length ? points : state.base[mode];
          if (!Array.isArray(source) || !source.length) {
            assignPart(null);
            if (mode === 'inner') {
              inner.style.display = 'none';
            } else {
              group.style.display = 'none';
            }
            return;
          }

          const mapped = inverseMatrix ? mapPoints(source, inverseMatrix) : source;
          if (!Array.isArray(mapped) || !mapped.length) {
            assignPart(null);
            if (mode === 'inner') {
              inner.style.display = 'none';
            } else {
              group.style.display = 'none';
            }
            return;
          }

          const processed = mapped.map((pt) => ({ x: pt.x, y: pt.y }));
          assignPart({
            points: processed,
            ids: Array.isArray(ids) ? ids.slice() : []
          });
          refresh();
        }
      };
    }

    const FACE_FEATURE_FACTORIES = {
      brow: createBrowHandler,
      eye: createEyeHandler,
      skin: createSkinHandler,
      nose: createNoseHandler,
      mouth: createMouthHandler
    };

    function buildFaceFeature(options = {}) {
      if (!options || !options.type) return null;
      const key = options.sharedKey || options.id || null;
      const fallback = Array.isArray(options.fallback) ? options.fallback : null;
      if (key && faceFeatureRegistry.has(key)) {
        const cached = faceFeatureRegistry.get(key);
        if (cached && typeof cached.setBase === 'function' && fallback) {
          cached.setBase(fallback, options.part);
        }
        if (cached && options.id && cached.el && !cached.el.id) {
          cached.el.id = options.id;
        }
        return cached;
      }
      const factory = FACE_FEATURE_FACTORIES[options.type];
      if (!factory) return null;
      const handler = factory(options) || null;
      if (handler && handler.el && options.id && !handler.el.id) {
        handler.el.id = options.id;
      }
      if (handler && typeof handler.setBase === 'function' && fallback) {
        handler.setBase(fallback, options.part);
      }
      if (key && handler) {
        faceFeatureRegistry.set(key, handler);
      }
      return handler;
    }

    function readPoint(id) {
      if (!svgEl) return null;
      const el = svgEl.getElementById(id);
      if (!el) return null;
      const cx = el.getAttribute('cx') ?? el.getAttribute('x') ?? el.getAttribute('x1');
      const cy = el.getAttribute('cy') ?? el.getAttribute('y') ?? el.getAttribute('y1');
      if (cx == null || cy == null) return null;
      const x = parseFloat(cx);
      const y = parseFloat(cy);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x, y };
    }

    function readTemplatePoint(id) {
      if (!faceTemplatesRoot || !id) return null;
      const el = faceTemplatesRoot.querySelector(`[id='${id}']`);
      if (!el) return null;
      const cx = el.getAttribute('cx') ?? el.getAttribute('x') ?? el.getAttribute('x1');
      const cy = el.getAttribute('cy') ?? el.getAttribute('y') ?? el.getAttribute('y1');
      if (cx == null || cy == null) return null;
      const x = parseFloat(cx);
      const y = parseFloat(cy);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x, y };
    }

    function parseStyleAttribute(value) {
      if (typeof value !== 'string') return {};
      const styles = {};
      const entries = value.split(';');
      for (const entry of entries) {
        if (!entry) continue;
        const [rawKey, rawVal] = entry.split(':');
        if (!rawKey || rawVal == null) continue;
        const key = rawKey.trim();
        const val = rawVal.trim();
        if (!key) continue;
        styles[key] = val;
      }
      return styles;
    }

    function sanitizeTemplateClone(node) {
      if (!node) return node;
      const styleAttr = node.getAttribute('style');
      if (styleAttr) {
        const styles = parseStyleAttribute(styleAttr);
        if (styles.display) delete styles.display;
        const serialized = Object.entries(styles)
          .map(([key, val]) => `${key}:${val}`)
          .join(';');
        if (serialized) node.setAttribute('style', serialized);
        else node.removeAttribute('style');
      }
      if (node.getAttribute('display') === 'none') {
        node.removeAttribute('display');
      }
      return node;
    }

    function cloneTemplateNode(id) {
      if (!svgEl || !id) return null;
      const template = svgEl.getElementById(id);
      if (!template) return null;
      const clone = template.cloneNode(true);
      sanitizeTemplateClone(clone);
      if (typeof clone.querySelectorAll === 'function') {
        const descendants = clone.querySelectorAll('*');
        for (const child of descendants) {
          sanitizeTemplateClone(child);
        }
      }
      return clone;
    }

    function applyTemplateStyles(source, target, attrs = [], fallback = {}) {
      if (!target) return;
      const styleMap = source ? parseStyleAttribute(source.getAttribute?.('style')) : {};
      for (const attr of attrs) {
        const value = source?.getAttribute ? source.getAttribute(attr) : null;
        const styleValue = styleMap?.[attr];
        const finalValue = value ?? styleValue;
        if (finalValue != null) {
          target.setAttribute(attr, finalValue);
        }
      }
      for (const [attr, value] of Object.entries(fallback)) {
        if (value == null) continue;
        if (!target.hasAttribute(attr)) {
          target.setAttribute(attr, value);
        }
      }
    }

    function setPolylinePoints(polyline, pointIds) {
      if (!polyline || !Array.isArray(pointIds)) return null;
      const pts = [];
      for (const id of pointIds) {
        const pt = readPoint(id);
        if (!pt) return null;
        pts.push(pt);
      }
      placePolyline(polyline, pts);
      return pts;
    }

    function alignLimbToPuppet(rawArm, lengths) {
      if (!rawArm || !lengths) return null;
      const { A, B, C } = rawArm;
      if (!A || !B || !C) return null;
      const upperDx = B.x - A.x;
      const upperDy = B.y - A.y;
      const upperLen = Math.hypot(upperDx, upperDy);
      if (upperLen < 1e-3) return null;
      const upperUnitX = upperDx / upperLen;
      const upperUnitY = upperDy / upperLen;
      const alignedB = {
        x: A.x + upperUnitX * lengths.upper,
        y: A.y + upperUnitY * lengths.upper
      };

      const lowerDx = C.x - B.x;
      const lowerDy = C.y - B.y;
      const lowerLen = Math.hypot(lowerDx, lowerDy);
      if (lowerLen < 1e-3) {
        return { A, B: alignedB, C: alignedB };
      }
      const lowerUnitX = lowerDx / lowerLen;
      const lowerUnitY = lowerDy / lowerLen;
      const alignedC = {
        x: alignedB.x + lowerUnitX * lengths.lower,
        y: alignedB.y + lowerUnitY * lengths.lower
      };

      return { A, B: alignedB, C: alignedC };
    }

    function alignSegmentToLength(origin, target, length) {
      if (!origin || !target) return null;
      const dx = target.x - origin.x;
      const dy = target.y - origin.y;
      const len = Math.hypot(dx, dy);
      if (len < 1e-3) return {
        x: origin.x,
        y: origin.y + length
      };
      const scale = length / len;
      return {
        x: origin.x + dx * scale,
        y: origin.y + dy * scale
      };
    }

    function computeTorsoRig(LSh, RSh, LH, RH, rig) {
      if (!LSh || !RSh || !LH || !RH || !rig) return null;
      const leftShoulder = toRig(LSh, rig);
      const rightShoulder = toRig(RSh, rig);
      const rawLeftHip = toRig(LH, rig);
      const rawRightHip = toRig(RH, rig);
      if (!leftShoulder || !rightShoulder || !rawLeftHip || !rawRightHip) return null;

      const topMid = mid(leftShoulder, rightShoulder);
      const rawBottomMid = mid(rawLeftHip, rawRightHip);
      const centerBottom = alignSegmentToLength(topMid, rawBottomMid, PUPPET_TORSO_CENTER_LEN) || rawBottomMid;

      const hipDirDx = rawRightHip.x - rawLeftHip.x;
      const hipDirDy = rawRightHip.y - rawLeftHip.y;
      const hipDirLen = Math.hypot(hipDirDx, hipDirDy);
      const hipDir = hipDirLen < 1e-3
        ? { x: 1, y: 0 }
        : { x: hipDirDx / hipDirLen, y: hipDirDy / hipDirLen };

      const hipHalf = PUPPET_HIP_SPAN / 2;
      const hipLeftBase = {
        x: centerBottom.x - hipDir.x * hipHalf,
        y: centerBottom.y - hipDir.y * hipHalf
      };
      const hipRightBase = {
        x: centerBottom.x + hipDir.x * hipHalf,
        y: centerBottom.y + hipDir.y * hipHalf
      };

      let leftHip = alignSegmentToLength(leftShoulder, hipLeftBase, PUPPET_LEFT_TORSO_LEN) || hipLeftBase;
      let rightHip = alignSegmentToLength(rightShoulder, hipRightBase, PUPPET_RIGHT_TORSO_LEN) || hipRightBase;

      const bottomMid = mid(leftHip, rightHip);
      const desiredBottomMid = alignSegmentToLength(topMid, bottomMid, PUPPET_TORSO_CENTER_LEN) || bottomMid;
      const correction = {
        x: desiredBottomMid.x - bottomMid.x,
        y: desiredBottomMid.y - bottomMid.y
      };

      leftHip = { x: leftHip.x + correction.x, y: leftHip.y + correction.y };
      rightHip = { x: rightHip.x + correction.x, y: rightHip.y + correction.y };

      return {
        shoulders: { left: leftShoulder, right: rightShoulder },
        hips: { left: leftHip, right: rightHip },
        centerTop: topMid,
        centerBottom: desiredBottomMid
      };
    }

    function computeArmRig(side, shoulder, elbow, wrist, rig, lengths) {
      if (!rig || !lengths) return lastArmRigs[side] || null;
      if (shoulder && elbow && wrist) {
        const raw = {
          A: toRig(shoulder, rig),
          B: toRig(elbow, rig),
          C: toRig(wrist, rig)
        };
        if (!raw.A || !raw.B || !raw.C) {
          return lastArmRigs[side] || null;
        }
        const aligned = alignLimbToPuppet(raw, lengths) || raw;
        lastArmRigs[side] = aligned;
        return aligned;
      }
      return lastArmRigs[side] || null;
    }

    function updateFaceGuides(kp, rig, anchors = {}) {
      if (!rig || !segments.face.length) return;
      let headMatrix = null;
      let contourTarget = null;
      let contourFallback = null;
      let contourAnchorIndex = -1;
      const pendingUpdates = [];
      for (const segment of segments.face) {
        const { debug, handler, handlerEl, featurePart, ids, fallback, isContour, anchorIndex } = segment;
        const points = [];
        let missingPosePoint = false;
        let aborted = false;
        for (let i = 0; i < ids.length; i += 1) {
          const id = ids[i];
          const raw = safeKP(kp, id);
          if (raw) {
            const mapped = toRig(raw, rig);
            if (mapped) {
              points.push(mapped);
              continue;
            }
          }
          missingPosePoint = true;
          if (fallback && fallback[i]) {
            points.push(fallback[i]);
            continue;
          }
          aborted = true;
          break;
        }

        let target = null;
        if (!aborted && points.length === ids.length) {
          placePolyline(debug, points);
          target = points;
        } else if (fallback && fallback.length) {
          placePolyline(debug, fallback);
          target = fallback;
        }

        if (isContour && !headMatrix && fallback && target && fallback.length && target.length) {
          headMatrix = computeSimilarityTransform(fallback, target);
          contourTarget = target;
          contourFallback = fallback;
          contourAnchorIndex = typeof anchorIndex === 'number' ? anchorIndex : -1;
        }

        const hasAllPoints = !missingPosePoint && !aborted && points.length === ids.length;
        pendingUpdates.push({
          segment,
          target: hasAllPoints ? points : null,
          fallback,
          visible: hasAllPoints
        });
      }
      if (headMatrix && contourFallback && contourTarget && headAnchorBase) {
        if (!headAnchorOffset) {
          headAnchorOffset = {
            x: headAnchorBase.x - PUPPET_SHOULDERS_MID.x,
            y: headAnchorBase.y - PUPPET_SHOULDERS_MID.y
          };
        }
        const offset = headAnchorOffset || { x: 0, y: 0 };
        let desiredAnchor = null;
        if (anchors.neck) {
          desiredAnchor = {
            x: anchors.neck.x + offset.x,
            y: anchors.neck.y + offset.y
          };
        } else if (contourTarget && contourAnchorIndex >= 0 && contourAnchorIndex < contourTarget.length) {
          desiredAnchor = contourTarget[contourAnchorIndex];
        }
        if (!desiredAnchor && contourFallback && contourAnchorIndex >= 0 && contourAnchorIndex < contourFallback.length) {
          desiredAnchor = transformPoint(lastHeadMatrix || headMatrix, contourFallback[contourAnchorIndex]);
        }
        if (desiredAnchor) {
          desiredAnchor = {
            x: desiredAnchor.x + (FACE_ANCHOR_ADJUST.x ?? 0),
            y: desiredAnchor.y + (FACE_ANCHOR_ADJUST.y ?? 0)
          };
          const currentAnchorSource = contourFallback && contourAnchorIndex >= 0 ? contourFallback[contourAnchorIndex] : headAnchorBase;
          const currentAnchor = transformPoint(headMatrix, currentAnchorSource);
          if (currentAnchor) {
            const dx = desiredAnchor.x - currentAnchor.x;
            const dy = desiredAnchor.y - currentAnchor.y;
            headMatrix = {
              ...headMatrix,
              e: headMatrix.e + dx,
              f: headMatrix.f + dy
            };
          }
        }
      }

      if (headMatrix && contourFallback && contourTarget) {
        validateSegment('face-contour', contourFallback, contourTarget, headMatrix);
      }

      const headInverse = headMatrix ? invertMatrix(headMatrix) : null;

      for (const update of pendingUpdates) {
        const { segment, target, fallback, visible } = update;
        const { handler, handlerEl, featurePart, ids } = segment;
        if (!handler) continue;
        const element = handlerEl || (handler && handler.el) || null;
        handler.update({
          points: target,
          part: featurePart,
          fallback,
          ids,
          element,
          matrix: headMatrix,
          inverseMatrix: headInverse,
          contourFallback,
          contourTarget,
          visible
        });
      }

      applyHeadTransform(headMatrix);
    }

    function tick(timestamp) {
      if (!running) return;
      if (!frames.length) {
        requestAnimationFrame(tick);
        return;
      }

      if (typeof timestamp !== 'number') {
        timestamp = performance.now();
      }

      if (lastTickTime == null) {
        lastTickTime = timestamp;
      }

      let delta = timestamp - lastTickTime;
      if (!Number.isFinite(delta) || delta < 0) {
        delta = 0;
      }
      const MAX_STEP = BASE_FRAME_DURATION * 5;
      if (delta > MAX_STEP) {
        delta = MAX_STEP;
      }

      lastTickTime = timestamp;

      const effectiveSpeed = Math.max(playbackSpeed, 0);
      frameAccumulator += (delta / BASE_FRAME_DURATION) * effectiveSpeed;
      if (frameAccumulator >= 1) {
        const steps = Math.floor(frameAccumulator);
        frameAccumulator -= steps;
        frameIndex = (frameIndex + steps) % frames.length;
      }

      const frame = frames[frameIndex];
      const kp = frame?.keypoints;
      if (!kp) {
        frameIndex = (frameIndex + 1) % frames.length;
        requestAnimationFrame(tick);
        return;
      }

      const rig = rigFromPose(kp);
      if (!rig) {
        frameIndex = (frameIndex + 1) % frames.length;
        requestAnimationFrame(tick);
        return;
      }

      const LSh = safeKP(kp, 'leftShoulder');
      const LE = safeKP(kp, 'leftElbow');
      const LW = safeKP(kp, 'leftWrist');
      const RSh = safeKP(kp, 'rightShoulder');
      const RE = safeKP(kp, 'rightElbow');
      const RW = safeKP(kp, 'rightWrist');
      const LH = safeKP(kp, 'leftHip');
      const RH = safeKP(kp, 'rightHip');

      const leftArmRig = computeArmRig('left', LSh, LE, LW, rig, {
        upper: PUPPET_UPPER_ARM_LEN,
        lower: PUPPET_LOWER_ARM_LEN
      });
      const rightArmRig = computeArmRig('right', RSh, RE, RW, rig, {
        upper: PUPPET_RIGHT_UPPER_ARM_LEN,
        lower: PUPPET_RIGHT_LOWER_ARM_LEN
      });
      const torsoRig = computeTorsoRig(LSh, RSh, LH, RH, rig);
      const handsRaw = extractHandsFromFrame(frame, kp);
      const hands = smoothHands(handsRaw);

      if (leftArmRig) {
        const { A, B, C } = leftArmRig;
        if (armPaths.left) {
          armPaths.left.setAttribute('d', `M ${A.x} ${A.y} L ${B.x} ${B.y} L ${C.x} ${C.y}`);
        }
        placeLine(segments.left.upper, A, B);
        placeLine(segments.left.lower, B, C);
      }

      if (rightArmRig) {
        const { A, B, C } = rightArmRig;
        if (armPaths.right) {
          armPaths.right.setAttribute('d', `M ${A.x} ${A.y} L ${B.x} ${B.y} L ${C.x} ${C.y}`);
        }
        placeLine(segments.right.upper, A, B);
        placeLine(segments.right.lower, B, C);
      }

      applyArmRig('left', leftArmRig);
      applyArmRig('right', rightArmRig);
      updateHandsDebug(hands, rig);

      let neckBase = null;
      if (torsoRig) {
        const { shoulders, hips, centerTop, centerBottom } = torsoRig;
        placeLine(segments.body.top, shoulders.left, shoulders.right);
        placeLine(segments.body.bottom, hips.left, hips.right);
        placeLine(segments.body.left, shoulders.left, hips.left);
        placeLine(segments.body.right, shoulders.right, hips.right);
        placeLine(segments.body.center, centerTop, centerBottom);
        let bodyMatrix = computeSimilarityTransform(PUPPET_BODY_BASE, [
          shoulders.right,
          shoulders.left,
          hips.right,
          hips.left
        ]);
        if (bodyMatrix) {
          bodyMatrix = adjustMatrixTranslation(bodyMatrix, [
            { base: PUPPET_LEFT_SH, target: shoulders.left },
            { base: PUPPET_RIGHT_SH, target: shoulders.right },
            { base: PUPPET_SHOULDERS_MID, target: centerTop }
          ]);
          validateSegment('torso', PUPPET_BODY_BASE, [
            shoulders.right,
            shoulders.left,
            hips.right,
            hips.left
          ], bodyMatrix);
        }
        applyBodyTransform(bodyMatrix);
        const torsoAnchor = applyTorsoRig(torsoRig);
        if (torsoAnchor) {
          neckBase = torsoAnchor;
        } else if (bodyMatrix) {
          neckBase = transformPoint(bodyMatrix, PUPPET_SHOULDERS_MID) || centerTop;
        } else {
          neckBase = centerTop;
        }
      } else if (LSh && RSh) {
        const fallbackTorso = {
          shoulders: {
            left: toRig(LSh, rig),
            right: toRig(RSh, rig)
          }
        };
        const torsoAnchor = applyTorsoRig(fallbackTorso);
        neckBase = torsoAnchor || toRig(mid(LSh, RSh), rig);
        applyBodyTransform(null);
      } else {
        applyBodyTransform(null);
        applyTorsoRig(null);
      }

      updateFaceGuides(kp, rig, { neck: neckBase });

      requestAnimationFrame(tick);
    }

    function tryStart() {
      if (!running && svgEl && frames.length) {
        running = true;
        frameAccumulator = 0;
        lastTickTime = null;
        requestAnimationFrame(tick);
      }
    }

    fetch('../boy.svg')
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status} ao carregar boy.svg`);
        return res.text();
      })
      .then((svgMarkup) => {
        stage.innerHTML = svgMarkup;
        svgEl = stage.querySelector('svg');
        if (!svgEl) throw new Error('boy.svg não possui elemento <svg>');
        svgEl.removeAttribute('width');
        svgEl.removeAttribute('height');
        svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svgEl.style.width = '100%';
        svgEl.style.height = 'auto';
        normalizePuppetStructure();
        ensureTorso(svgEl);
        faceTemplatesRoot = svgEl.getElementById('face_templates');
        updatePuppetMeasurementsFromSkeleton();
        if (faceTemplatesRoot) {
          computeFaceAnchorAdjustments();
        }
        headTargets = [];
        bodyTargets = [];
        const headRig = svgEl.getElementById('puppet_head_rig');
        const headBase = svgEl.getElementById('puppet_head_base');
        const headFront = svgEl.getElementById('puppet_head_front');
        if (headRig) {
          headTargets.push(headRig);
        } else {
          if (headBase) headTargets.push(headBase);
          if (headFront) headTargets.push(headFront);
        }
        lastHeadMatrix = null;
        lastBodyMatrix = null;
        lastRigMatrix = null;
        lastArmMatrices.left.upper = null;
        lastArmMatrices.left.lower = null;
        lastArmMatrices.right.upper = null;
        lastArmMatrices.right.lower = null;
        const bodyGroup = svgEl.getElementById('puppet_body');
        if (bodyGroup) bodyTargets.push(bodyGroup);
        applyBodyTransform(null);
        faceOverlayLayer = svgEl.getElementById(FACE_OVERLAY_ID) || svgEl.getElementById(LEGACY_FACE_OVERLAY_ID);
        if (!faceOverlayLayer) {
          faceOverlayLayer = document.createElementNS(NS, 'g');
        }
        faceOverlayLayer.id = FACE_OVERLAY_ID;
        faceOverlayLayer.setAttribute('aria-label', 'face overlay');
        faceOverlayLayer.style.pointerEvents = 'none';
        faceOverlayGroups.clear();
        if (!faceOverlayLayer.parentNode) {
          svgEl.appendChild(faceOverlayLayer);
        }
        ensureFaceOverlayGroups();
        positionFaceOverlayLayer();
        if (faceOverlayLayer && !headTargets.includes(faceOverlayLayer)) {
          headTargets.push(faceOverlayLayer);
        }
        faceFeatureRegistry.clear();
        headAnchorBase = null;
        headAnchorOffset = null;
        const skel = svgEl.getElementById('skeleton_1_');
        if (skel) skel.style.display = 'none';
        armPaths.left = document.createElementNS(NS, 'path');
        armPaths.left.id = 'L_arm_path';
        armPaths.left.setAttribute('fill', 'none');
        armPaths.left.setAttribute('stroke', '#99AFB1');
        armPaths.left.setAttribute('stroke-width', '64');
        armPaths.left.setAttribute('stroke-linecap', 'round');
        armPaths.left.setAttribute('stroke-linejoin', 'round');
        armPaths.left.setAttribute('stroke-opacity', '0.95');
        armPaths.left.setAttribute('data-debug-line', 'true');
        svgEl.appendChild(armPaths.left);

        armPaths.right = document.createElementNS(NS, 'path');
        armPaths.right.id = 'R_arm_path';
        armPaths.right.setAttribute('fill', 'none');
        armPaths.right.setAttribute('stroke', '#99AFB1');
        armPaths.right.setAttribute('stroke-width', '64');
        armPaths.right.setAttribute('stroke-linecap', 'round');
        armPaths.right.setAttribute('stroke-linejoin', 'round');
        armPaths.right.setAttribute('stroke-opacity', '0.95');
        armPaths.right.setAttribute('data-debug-line', 'true');
        svgEl.appendChild(armPaths.right);
        segments.left.upper = seg('L_upper');
        segments.left.lower = seg('L_lower');
        segments.right.upper = seg('R_upper');
        segments.right.lower = seg('R_lower');
        segments.body.top = seg('body_top', '#4a8bff', 12);
        segments.body.bottom = seg('body_bottom', '#4a8bff', 12);
        segments.body.left = seg('body_left', '#4a8bff', 12);
        segments.body.right = seg('body_right', '#4a8bff', 12);
        segments.body.center = seg('body_center', '#4a8bff', 10);

        const faceGuides = [
          {
            id: 'face_contour',
            isContour: true,
            ids: [
              'topMid', 'rightTop0', 'rightTop1', 'rightJaw0', 'rightJaw1', 'rightJaw2',
              'rightJaw3', 'rightJaw4', 'rightJaw5', 'rightJaw6', 'rightJaw7', 'jawMid',
              'leftJaw7', 'leftJaw6', 'leftJaw5', 'leftJaw4', 'leftJaw3', 'leftJaw2',
              'leftJaw1', 'leftJaw0', 'leftTop1', 'leftTop0', 'topMid'
            ],
            width: 8
          },
          {
            id: 'face_skin_jaw',
            ids: [
              'rightJaw0', 'rightJaw1', 'rightJaw2', 'rightJaw3', 'rightJaw4', 'rightJaw5',
              'rightJaw6', 'rightJaw7', 'jawMid', 'leftJaw7', 'leftJaw6', 'leftJaw5',
              'leftJaw4', 'leftJaw3', 'leftJaw2', 'leftJaw1', 'leftJaw0'
            ],
            width: 5,
            feature: {
              type: 'skin',
              id: 'skin_jaw_feature',
              sharedKey: 'skin_jaw',
              part: 'jaw',
              baseColor: '#F3AF9D'
            }
          },
          {
            id: 'face_skin_cheek_right',
            ids: ['rightEye4', 'rightMouthCorner', 'rightJaw4'],
            width: 4,
            feature: {
              type: 'skin',
              id: 'skin_cheek_right',
              sharedKey: 'skin_cheek_right',
              part: 'cheek',
              side: 'right',
              baseColor: '#F3AF9D'
            }
          },
          {
            id: 'face_skin_cheek_left',
            ids: ['leftEye4', 'leftMouthCorner', 'leftJaw4'],
            width: 4,
            feature: {
              type: 'skin',
              id: 'skin_cheek_left',
              sharedKey: 'skin_cheek_left',
              part: 'cheek',
              side: 'left',
              baseColor: '#F3AF9D'
            }
          },
          {
            id: 'face_brow_right',
            ids: ['rightBrow0', 'rightBrow1', 'rightBrow2', 'rightBrow3', 'rightBrow4'],
            feature: {
              type: 'brow',
              id: 'brow_right_feature',
              sharedKey: 'brow_right',
              strokeWidth: 12,
              tension: 0.58,
              templateId: 'template_brow_right'
            }
          },
          {
            id: 'face_brow_left',
            ids: ['leftBrow0', 'leftBrow1', 'leftBrow2', 'leftBrow3', 'leftBrow4'],
            feature: {
              type: 'brow',
              id: 'brow_left_feature',
              sharedKey: 'brow_left',
              strokeWidth: 12,
              tension: 0.58,
              templateId: 'template_brow_left'
            }
          },
          {
            id: 'face_eye_right',
            ids: ['rightEye0', 'rightEye1', 'rightEye2', 'rightEye3', 'rightEye4', 'rightEye5', 'rightEye0'],
            width: 5,
            feature: {
              type: 'eye',
              id: 'eye_right_feature',
              sharedKey: 'eye_right',
              side: 'right',
              strokeWidth: 4,
              templateId: 'template_eye_right'
            }
          },
          {
            id: 'face_eye_left',
            ids: ['leftEye0', 'leftEye1', 'leftEye2', 'leftEye3', 'leftEye4', 'leftEye5', 'leftEye0'],
            width: 5,
            feature: {
              type: 'eye',
              id: 'eye_left_feature',
              sharedKey: 'eye_left',
              side: 'left',
              strokeWidth: 4,
              templateId: 'template_eye_left'
            }
          },
          {
            id: 'face_nose_bridge',
            ids: ['nose0', 'nose1', 'nose2', 'nose3', 'nose4'],
            feature: {
              type: 'nose',
              id: 'nose_feature',
              sharedKey: 'nose',
              part: 'bridge',
              stroke: '#2C323A',
              templateId: 'template_nose'
            }
          },
          {
            id: 'face_nose_base',
            ids: ['rightNose0', 'rightNose1', 'nose4', 'leftNose1', 'leftNose0'],
            width: 5,
            feature: {
              type: 'nose',
              id: 'nose_feature',
              sharedKey: 'nose',
              part: 'base',
              stroke: '#2C323A',
              templateId: 'template_nose'
            }
          },
          {
            id: 'face_mouth_outer',
            ids: [
              'rightMouthCorner', 'rightUpperLipTop0', 'rightUpperLipTop1', 'upperLipTopMid',
              'leftUpperLipTop1', 'leftUpperLipTop0', 'leftMouthCorner', 'leftLowerLipBottom0',
              'leftLowerLipBottom1', 'lowerLipBottomMid', 'rightLowerLipBottom1', 'rightLowerLipBottom0',
              'rightMouthCorner'
            ],
            width: 7,
            feature: {
              type: 'mouth',
              id: 'mouth_feature',
              sharedKey: 'mouth',
              part: 'outer',
              templateId: 'template_mouth'
            }
          },
          {
            id: 'face_mouth_inner',
            ids: [
              'rightMouthCorner', 'rightUpperLipBottom1', 'upperLipBottomMid', 'leftUpperLipBottom1',
              'leftMouthCorner', 'leftLowerLipTop0', 'lowerLipTopMid', 'rightLowerLipTop0', 'rightMouthCorner'
            ],
            width: 4,
            feature: {
              type: 'mouth',
              sharedKey: 'mouth',
              part: 'inner',
              templateId: 'template_mouth'
            }
          }
        ];

        for (const guide of faceGuides) {
          const debug = faceGuide(guide.id, '#4a8bff', guide.width ?? 6);
          const fallbackPoints = setPolylinePoints(debug, guide.ids);
          if (!fallbackPoints) {
            console.warn(`Não foi possível construir a linha de rosto ${guide.id}`);
            debug.remove();
            continue;
          }
          const fallback = fallbackPoints.map((pt) => ({ x: pt.x, y: pt.y }));
          placePolyline(debug, fallback);

          let handler = null;
          let handlerEl = null;
          let featurePart = null;
          if (guide.feature) {
            handler = buildFaceFeature({ ...guide.feature, fallback });
            handlerEl = handler?.el || null;
            featurePart = guide.feature.part ?? null;
            if (handler && typeof handler.update === 'function') {
              handler.update({
                points: fallback,
                part: featurePart,
                fallback,
                ids: guide.ids,
                element: handlerEl,
                matrix: null
              });
            }
          }

          const anchorIndex = guide.isContour ? guide.ids.indexOf(HEAD_ANCHOR_ID) : -1;
          segments.face.push({
            debug,
            handler,
            handlerEl,
            featurePart,
            ids: guide.ids,
            fallback,
            isContour: Boolean(guide.isContour),
            anchorIndex
          });

          if (guide.isContour && anchorIndex >= 0 && fallback[anchorIndex]) {
            headAnchorBase = {
              x: fallback[anchorIndex].x,
              y: fallback[anchorIndex].y
            };
            headAnchorOffset = null;
          }
        }

        const attachArmPart = (el) => {
          if (!el) return;
          el.style.transformBox = 'fill-box';
          el.classList.add('joint');
          el.removeAttribute('transform');
          el.style.transform = '';
          el.style.transformOrigin = '';
          if (el.parentNode) {
            el.parentNode.appendChild(el);
          }
        };

        ensurePuppetArm('left', svgEl);
        ensurePuppetArm('right', svgEl);
        ensureDebugHands(svgEl);

        ['left', 'right'].forEach((side) => {
          const arm = puppetArms[side];
          if (!arm.ready && !arm.warningShown) {
            const sideLabel = side === 'left' ? 'esquerdo' : 'direito';
            console.warn(`Braço ${sideLabel} do puppet não encontrado em boy.svg; mantendo modo debug.`);
            arm.warningShown = true;
          }
          attachArmPart(arm.upper);
          attachArmPart(arm.lower);
        });

        updateVisibility();
        positionFaceOverlayLayer();
        tryStart();
      })
      .catch((err) => {
        console.error(err);
        showError('Erro ao carregar boy.svg: ' + err.message);
      });

    fetch('pose_frames.json')
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status} ao carregar pose_frames.json`);
        return res.json();
      })
      .then((data) => {
        if (!Array.isArray(data) || !data.length) {
          throw new Error('Arquivo pose_frames.json vazio ou inválido.');
        }
        frames = data;
        frameIndex = 0;
        frameAccumulator = 0;
        lastTickTime = null;
        resetHandSmoothing();
        tryStart();
      })
      .catch((err) => {
        console.error(err);
        showError('Erro ao carregar pose_frames.json: ' + err.message);
      });

    if (speedControl) {
      const updatePlaybackSpeed = (value) => {
        const parsed = Number.parseFloat(value);
        playbackSpeed = Number.isFinite(parsed) ? parsed : DEFAULT_PLAYBACK_SPEED;
        if (playbackSpeed < 0) playbackSpeed = 0;
        updateSpeedIndicator(playbackSpeed);
        frameAccumulator = 0;
        lastTickTime = null;
      };

      updatePlaybackSpeed(speedControl.value ?? DEFAULT_PLAYBACK_SPEED);

      speedControl.addEventListener('input', (event) => {
        updatePlaybackSpeed(event.target.value);
      });

      speedControl.addEventListener('change', (event) => {
        updatePlaybackSpeed(event.target.value);
      });
    } else {
      updateSpeedIndicator(DEFAULT_PLAYBACK_SPEED);
    }

    const toggleButtons = Array.from(document.querySelectorAll('[data-toggle-target]'));
    toggleButtons.forEach((button) => {
      const target = button.dataset.toggleTarget;
      if (!target || !(target in debugToggles)) return;
      button.classList.toggle('inactive', !debugToggles[target]);
      button.setAttribute('aria-pressed', String(debugToggles[target]));
      button.addEventListener('click', () => {
        debugToggles[target] = !debugToggles[target];
        button.classList.toggle('inactive', !debugToggles[target]);
        button.setAttribute('aria-pressed', String(debugToggles[target]));
        updateVisibility();
      });
    });
  </script>
</body>
</html>
